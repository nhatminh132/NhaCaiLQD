# -*- coding: utf-8 -*-
import discord
from discord.ext import commands, tasks
from discord import ui, app_commands # S·ª≠ d·ª•ng app_commands cho slash
import os
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone, date, time
from supabase import create_client, Client
import typing
import random
import asyncio
import math
import discord.utils
import pytz # Th√™m th∆∞ vi·ªán m√∫i gi·ªù
import re # Th√™m th∆∞ vi·ªán regex cho c∆∞·ª£c Roulette ph·ª©c t·∫°p

# Import t·ªáp keep_alive
from keep_alive import keep_alive

# --- T·∫£i Token v√† C√†i ƒë·∫∑t Bot ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_KEY = os.getenv('SUPABASE_KEY')

# --- C√†i ƒë·∫∑t Supabase ---
if not SUPABASE_URL or not SUPABASE_KEY: print("L·ªñI: Kh√¥ng t√¨m th·∫•y SUPABASE_URL ho·∫∑c SUPABASE_KEY"); exit()
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- C√†i ƒë·∫∑t Bot Discord (S·ª¨ D·ª§NG discord.Bot cho Slash Commands) ---
intents = discord.Intents.default()
# intents.message_content = True # C√≥ th·ªÉ b·∫≠t n·∫øu c·∫ßn ƒë·ªçc tin nh·∫Øn th∆∞·ªùng cho t√≠nh nƒÉng kh√°c
intents.members = True # C·∫ßn ƒë·ªÉ l·∫•y th√¥ng tin Member
bot = discord.Bot(intents=intents) # S·ª≠ d·ª•ng discord.Bot

# --- BI·∫æN TO√ÄN C·ª§C CHO GAME ---
game_message = None # Tin nh·∫Øn game T√†i X·ªâu
game_channel_id = None # K√™nh game T√†i X·ªâu
current_bets = {} # C∆∞·ª£c v√°n T√†i X·ªâu hi·ªán t·∫°i
bot.blackjack_games = {} # L∆∞u c√°c v√°n Blackjack
bot.mines_games = {} # L∆∞u c√°c v√°n D√≤ M√¨n
bot.users_in_animation = set() # D√πng ƒë·ªÉ kh√≥a l·ªánh khi game c√≥ hi·ªáu ·ª©ng
bot.guess_the_number_game = None # L∆∞u state game ƒêo√°n S·ªë
bot.spin_the_wheel_games = {} # L∆∞u c√°c v√°n V√≤ng Quay May M·∫Øn

# --- ƒê·ªäNH NGHƒ®A H·∫∞NG S·ªê ---
STARTING_TOKENS = 100
DAILY_REWARD = 50
DAILY_COOLDOWN_HOURS = 24
ADMIN_ROLE = "Bot Admin" # V·∫´n c·∫ßn cho c√°c l·ªánh admin kh√°c
VIETNAM_TZ = pytz.timezone('Asia/Ho_Chi_Minh')
LOTTERY_DRAW_TIME = time(18, 0, 0, tzinfo=VIETNAM_TZ)
LOTTERY_TICKET_PRICE = 100

# Roulette
RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]
BLACK_NUMBERS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35]
ROULETTE_PAYOUTS = {'single': 35, 'split': 17, 'street': 11, 'corner': 8, 'sixline': 5, 'dozen': 2, 'column': 2, 'color': 1, 'evenodd': 1, 'half': 1}

# B·∫ßu Cua
BAU_CUA_FACES = {'b·∫ßu': 'B·∫ßu üçê', 'bau': 'B·∫ßu üçê', 'üçê': 'B·∫ßu üçê', 'cua': 'Cua ü¶Ä', 'ü¶Ä': 'Cua ü¶Ä', 't√¥m': 'T√¥m ü¶ê', 'tom': 'T√¥m ü¶ê', 'ü¶ê': 'T√¥m ü¶ê', 'c√°': 'C√° üêü', 'ca': 'C√° üêü', 'üêü': 'C√° üêü', 'g√†': 'G√† üêì', 'ga': 'G√† üêì', 'üêì': 'G√† üêì', 'nai': 'Nai ü¶å', 'ü¶å': 'Nai ü¶å'}
BAU_CUA_LIST = ['B·∫ßu üçê', 'Cua ü¶Ä', 'T√¥m ü¶ê', 'C√° üêü', 'G√† üêì', 'Nai ü¶å']

# ƒêua Ng·ª±a
NUM_HORSES = 6; RACE_LENGTH = 20

# M√°y X√®ng (Slots)
SLOT_SYMBOLS = [('üçí', 10, 10), ('üçã', 9, 15), ('üçä', 8, 20), ('üçì', 5, 30), ('üîî', 3, 50), ('üíé', 2, 100), ('7Ô∏è‚É£', 1, 200)]
SLOT_WHEEL, SLOT_WEIGHTS, SLOT_PAYOUTS = [], [], {}
for (symbol, weight, payout) in SLOT_SYMBOLS: SLOT_WHEEL.append(symbol); SLOT_WEIGHTS.append(weight); SLOT_PAYOUTS[symbol] = payout

# B√†i (Cards)
CARD_SUITS = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è']
# J=10, Q=10, K=10, A=1 (Baccarat), A=11/1 (BJ), A=14 (Hilo)
CARD_RANKS_BACCARAT = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 0, 'J': 0, 'Q': 0, 'K': 0, 'A': 1}
CARD_RANKS_BJ = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
CARD_RANKS_HILO = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}

# V√≤ng Quay May M·∫Øn
WHEEL_SEGMENTS = [('0.5x', 15, 0.5), ('1x', 20, 1.0), ('1.5x', 10, 1.5), ('2x', 8, 2.0), ('3x', 5, 3.0), ('5x', 3, 5.0), ('10x', 1, 10.0), ('üí£ M·∫•t', 10, 0.0)]
WHEEL_OPTIONS, WHEEL_WEIGHTS = [], []
for (label, weight, value) in WHEEL_SEGMENTS: WHEEL_OPTIONS.append((label, value)); WHEEL_WEIGHTS.append(weight)

# --- C√ÄI ƒê·∫∂T RATE LIMIT TO√ÄN C·ª§C ---
def global_rate_limit():
    async def predicate(interaction: discord.Interaction):
        # Kh√¥ng c·∫ßn check help v√¨ kh√¥ng c√≤n l·ªánh help
        bucket = global_cooldown.get_bucket(interaction)
        retry_after = bucket.update_rate_limit()
        if retry_after:
            raise app_commands.CommandOnCooldown(bucket, retry_after)
        return True
    return app_commands.check(predicate)

global_cooldown = commands.CooldownMapping.from_cooldown(30, 60.0, commands.BucketType.default)


# --- QU·∫¢N L√ù D·ªÆ LI·ªÜU (SUPABASE) ---
def get_user_data(user_id: int) -> typing.Dict:
    try:
        response = supabase.table('profiles').select('*').eq('user_id', user_id).single().execute()
        data = response.data
        if not data: raise Exception("User not found initially") # N√©m l·ªói n·∫øu single() tr·∫£ v·ªÅ None
        # ƒê·∫£m b·∫£o c√°c c·ªôt t·ªìn t·∫°i v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu thi·∫øu
        data.setdefault('balance', STARTING_TOKENS)
        data.setdefault('last_daily', None)
        data.setdefault('used_codes', [])
        data.setdefault('total_bet', 0)
        data.setdefault('total_won', 0)
        data.setdefault('games_played', 0)
        data.setdefault('daily_streak', 0)
        data.setdefault('last_streak_date', None)
        return data
    except Exception as e:
        if "JSON object requested" in str(e) or "User not found initially" in str(e): # User ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
             try:
                 insert_response = supabase.table('profiles').insert({'user_id': user_id, 'balance': STARTING_TOKENS, 'last_daily': None, 'used_codes': [], 'total_bet': 0, 'total_won': 0, 'games_played': 0, 'daily_streak': 0, 'last_streak_date': None}).execute()
                 return insert_response.data[0]
             except Exception as e2: print(f"L·ªói khi t·∫°o user m·ªõi {user_id}: {e2}"); return None
        else: print(f"L·ªói khi get_user_data cho {user_id}: {e}"); return None

def update_balance(user_id: int, amount: int) -> typing.Optional[int]:
    try:
        # G·ªçi RPC function ƒë√£ t·∫°o trong Supabase
        response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
        return response.data # Tr·∫£ v·ªÅ s·ªë d∆∞ m·ªõi
    except Exception as e:
        print(f"L·ªói khi update_balance cho {user_id}: {e}")
        # N·∫øu l·ªói c√≥ th·ªÉ do user ch∆∞a t·ªìn t·∫°i, th·ª≠ t·∫°o/l·∫•y l·∫°i
        user_data = get_user_data(user_id)
        if user_data: # N·∫øu user t·ªìn t·∫°i (ho·∫∑c v·ª´a ƒë∆∞·ª£c t·∫°o), th·ª≠ g·ªçi RPC l·∫°i
             try:
                 response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
                 return response.data
             except Exception as e2: print(f"L·ªói l·∫ßn 2 khi update_balance: {e2}")
        return None # Tr·∫£ v·ªÅ None n·∫øu v·∫´n l·ªói

def update_profile_stats(user_id: int, bet_amount: int, net_gain: int):
    try:
        user_data = get_user_data(user_id) # L·∫•y data ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh
        if not user_data: return

        new_total_bet = user_data.get('total_bet', 0) + bet_amount
        new_total_won = user_data.get('total_won', 0) + max(0, net_gain) # Ch·ªâ c·ªông ph·∫ßn l·ªùi
        new_games_played = user_data.get('games_played', 0) + 1

        supabase.table('profiles').update({
            'total_bet': new_total_bet,
            'total_won': new_total_won,
            'games_played': new_games_played
        }).eq('user_id', user_id).execute()
    except Exception as e: print(f"L·ªói khi update_profile_stats cho {user_id}: {e}")

def get_jackpot_pool(game_name: str):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        response = supabase.table(table_name).select('pool_amount').eq('game_name', game_name).maybe_single().execute()
        return response.data['pool_amount'] if response.data else 0
    except Exception as e: print(f"L·ªói khi l·∫•y jackpot {game_name}: {e}"); return 0

def update_jackpot_pool(game_name: str, amount: int):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        # S·ª≠ d·ª•ng atomic increment/decrement n·∫øu c√≥ th·ªÉ (v√≠ d·ª• qua RPC)
        # T·∫°m th·ªùi v·∫´n ƒë·ªçc-ghi
        current_pool = get_jackpot_pool(game_name)
        new_pool = max(0, current_pool + amount) # ƒê·∫£m b·∫£o h≈© kh√¥ng √¢m
        supabase.table(table_name).update({'pool_amount': new_pool}).eq('game_name', game_name).execute()
        return new_pool
    except Exception as e: print(f"L·ªói khi c·∫≠p nh·∫≠t jackpot {game_name}: {e}"); return get_jackpot_pool(game_name)

def get_taixiu_history():
    try:
        response = supabase.table('jackpot').select('history').eq('game_name', 'taixiu').maybe_single().execute()
        return response.data.get('history', [])[-10:] if response.data else []
    except Exception as e: print(f"Loi khi lay history taixiu: {e}"); return []


# --- H√ÄM KI·ªÇM TRA & S·ª∞ KI·ªÜN BOT ---
@bot.event
async def on_ready():
    # ƒêƒÉng k√Ω View persistent cho T√†i X·ªâu ƒë·ªÉ n√∫t ho·∫°t ƒë·ªông sau khi bot kh·ªüi ƒë·ªông l·∫°i
    bot.add_view(TaiXiuGameView())
    # Kh·ªüi ƒë·ªông task x·ªï s·ªë
    if not lottery_draw_task.is_running():
        lottery_draw_task.start()
    print(f'Bot {bot.user.name} ({bot.user.id}) ƒë√£ s·∫µn s√†ng!')
    # ƒê·ªìng b·ªô h√≥a Slash Commands
    try:
        synced = await bot.tree.sync()
        print(f"ƒê√£ ƒë·ªìng b·ªô h√≥a {len(synced)} l·ªánh ·ª©ng d·ª•ng.")
    except Exception as e:
        print(f"L·ªói khi ƒë·ªìng b·ªô h√≥a l·ªánh: {e}")
    print('------')

@bot.event
async def on_application_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    command_name = interaction.command.name if interaction.command else "Unknown"
    original_error = getattr(error, 'original', error)

    async def safe_response(content: str, ephemeral: bool = True, delete_after: typing.Optional[int] = None):
        try:
            if interaction.response.is_done(): await interaction.followup.send(content, ephemeral=ephemeral, delete_after=delete_after)
            else: await interaction.response.send_message(content, ephemeral=ephemeral, delete_after=delete_after)
        except discord.InteractionResponded:
            try: await interaction.followup.send(content, ephemeral=ephemeral, delete_after=delete_after)
            except Exception as e_inner: print(f"L·ªói g·ª≠i followup sau InteractionResponded: {e_inner}")
        except Exception as e_outer: print(f"L·ªói g·ª≠i ph·∫£n h·ªìi l·ªói chung: {e_outer}")

    if isinstance(error, app_commands.CommandOnCooldown):
        seconds = error.retry_after; await safe_response(f"‚è≥ Bot ƒëang x·ª≠ l√Ω qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng th·ª≠ l·∫°i sau **{seconds:.1f} gi√¢y**.", delete_after=5)
    elif isinstance(error, app_commands.MissingRole):
        await safe_response(f"R·∫•t ti·∫øc {interaction.user.mention}, b·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y. C·∫ßn role `{ADMIN_ROLE}`.")
    elif isinstance(error, app_commands.CheckFailure):
         await safe_response(f"‚è≥ {interaction.user.mention}, b·∫°n ƒëang c√≥ m·ªôt tr√≤ ch∆°i kh√°c ƒëang ch·∫°y ho·∫∑c kh√¥ng th·ªÉ th·ª±c hi·ªán l·ªánh n√†y ngay b√¢y gi·ªù.", delete_after=5)
    elif isinstance(error, app_commands.CommandInvokeError):
        if isinstance(original_error, ValueError) and "Invalid Roulette bet type" in str(original_error):
             bet_arg = interaction.data.get('options', [{}])[0].get('options', [{}])[-1].get('value', 'kh√¥ng r√µ')
             await safe_response(f"Lo·∫°i c∆∞·ª£c Roulette kh√¥ng h·ª£p l·ªá: `{bet_arg}`. G√µ `/` xem v√≠ d·ª•.")
        else:
            print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ l·ªánh '{command_name}': {original_error}")
            await safe_response('ƒê√£ x·∫£y ra l·ªói b√™n trong l·ªánh. Vui l√≤ng th·ª≠ l·∫°i sau.')
    elif isinstance(error, app_commands.TransformerError) or isinstance(error, app_commands.ArgumentParsingError):
         await safe_response(f'Tham s·ªë b·∫°n nh·∫≠p cho l·ªánh `{command_name}` kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.')
    else:
        print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ l·ªánh '{command_name}': {error}")
        await safe_response('ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh.')

# --- H√ÄM KI·ªÇM TRA GAME ƒêANG CH·∫†Y (CHO SLASH COMMANDS) ---
def is_user_not_in_game():
    async def predicate(interaction: discord.Interaction):
        user_id = interaction.user.id
        if user_id in bot.blackjack_games: return False
        if user_id in bot.mines_games: return False
        if user_id in bot.spin_the_wheel_games: return False
        # Cho ph√©p ƒëo√°n khi game ƒëo√°n s·ªë ƒëang ch·∫°y
        is_guessing = interaction.command and interaction.command.name == "guess" and interaction.command.parent and interaction.command.parent.name == "guess"
        if bot.guess_the_number_game and user_id in bot.guess_the_number_game.participants and not is_guessing:
             return False
        if user_id in bot.users_in_animation: return False
        return True
    return app_commands.check(predicate)

# --- L·ªÜNH SLASH COMMANDS ---

# --- L·ªÜNH C∆† B·∫¢N V√Ä X√É H·ªòI ---
@bot.slash_command(name="kiemtra", description="Ki·ªÉm tra s·ªë d∆∞ token ü™ô hi·ªán t·∫°i c·ªßa b·∫°n.")
@global_rate_limit()
async def balance_check_slash(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    user_data = get_user_data(interaction.user.id)
    await interaction.followup.send(f'ü™ô {interaction.user.mention}, b·∫°n ƒëang c√≥ **{user_data.get("balance", 0):,}** token.' if user_data else 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y s·ªë d∆∞ c·ªßa b·∫°n.')

@bot.slash_command(name="daily", description="Nh·∫≠n th∆∞·ªüng token h√†ng ng√†y v√† duy tr√¨ chu·ªói ƒëƒÉng nh·∫≠p.")
@global_rate_limit()
@is_user_not_in_game()
async def daily_reward_slash(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return

    can_claim = True; time_left_str = ""; current_streak = user_data.get('daily_streak', 0); last_streak_date_str = user_data.get('last_streak_date'); today = datetime.now(VIETNAM_TZ).date(); yesterday = today - timedelta(days=1)
    if user_data.get('last_daily'):
        try: last_daily_time = datetime.fromisoformat(user_data['last_daily']); cooldown = timedelta(hours=DAILY_COOLDOWN_HOURS)
        except: last_daily_time = None
        if last_daily_time and datetime.now(timezone.utc) < last_daily_time + cooldown:
            time_left = (last_daily_time + cooldown) - datetime.now(timezone.utc); hours_left = int(time_left.total_seconds() // 3600); minutes_left = int((time_left.total_seconds() % 3600) // 60)
            time_left_str = f'B·∫°n c·∫ßn ch·ªù **{hours_left} gi·ªù {minutes_left} ph√∫t** n·ªØa.'
            can_claim = False
    if not can_claim: await interaction.followup.send(f'{interaction.user.mention}, {time_left_str}'); return

    new_streak = 0; streak_bonus = 0
    if last_streak_date_str:
        try: last_streak_date = date.fromisoformat(last_streak_date_str)
        except: last_streak_date = None
        if last_streak_date == today: new_streak = current_streak
        elif last_streak_date == yesterday: new_streak = current_streak + 1
        else: new_streak = 1
    else: new_streak = 1
    streak_bonus = min(new_streak * 10, 100); total_reward = DAILY_REWARD + streak_bonus
    new_balance = update_balance(user_id, total_reward)
    if new_balance is None: await interaction.followup.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try:
        supabase.table('profiles').update({'last_daily': datetime.now(timezone.utc).isoformat(), 'daily_streak': new_streak, 'last_streak_date': str(today)}).eq('user_id', user_id).execute()
        streak_msg = f"üî• Chu·ªói ƒëƒÉng nh·∫≠p: **{new_streak} ng√†y** (+{streak_bonus}ü™ô bonus)!" if new_streak > 1 else "üî• B·∫Øt ƒë·∫ßu chu·ªói ƒëƒÉng nh·∫≠p!"
        await interaction.followup.send(f'üéâ {interaction.user.mention}, b·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **{total_reward}** token ({DAILY_REWARD} + {streak_bonus} bonus)! {streak_msg}\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await interaction.followup.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t th·ªùi gian/streak: {e}')

@bot.slash_command(name="code", description="Nh·∫≠p giftcode ƒë·ªÉ nh·∫≠n th∆∞·ªüng.")
@app_commands.describe(code_to_redeem="M√£ code b·∫°n mu·ªën nh·∫≠p")
@global_rate_limit()
@is_user_not_in_game()
async def redeem_code_slash(interaction: discord.Interaction, code_to_redeem: str):
    await interaction.response.defer(ephemeral=True)
    user_id = interaction.user.id; user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return
    code_to_redeem = code_to_redeem.upper()
    try: code_response = supabase.table('gift_codes').select('*').eq('code', code_to_redeem).execute()
    except Exception as e: await interaction.followup.send(f'L·ªói khi ki·ªÉm tra code: {e}'); return
    if not code_response.data: await interaction.followup.send(f'M√£ `{code_to_redeem}` kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.'); return
    if code_to_redeem in user_data.get('used_codes', []): await interaction.followup.send(f'B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ `{code_to_redeem}` n√†y r·ªìi.'); return
    reward = code_response.data[0]['reward']; new_balance = update_balance(user_id, reward)
    if new_balance is None: await interaction.followup.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try: new_code_list = user_data.get('used_codes', []) + [code_to_redeem]; supabase.table('profiles').update({'used_codes': new_code_list}).eq('user_id', user_id).execute(); await interaction.followup.send(f'üéÅ {interaction.user.mention}, b·∫°n ƒë√£ nh·∫≠p th√†nh c√¥ng m√£ `{code_to_redeem}` v√† nh·∫≠n ƒë∆∞·ª£c **{reward:,}** token! S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await interaction.followup.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t code ƒë√£ d√πng: {e}')

@bot.slash_command(name="top", description="Xem b·∫£ng x·∫øp h·∫°ng nh·ªØng ng∆∞·ªùi gi√†u nh·∫•t.")
@app_commands.describe(top_n="S·ªë l∆∞·ª£ng ng∆∞·ªùi mu·ªën xem (m·∫∑c ƒë·ªãnh 10)")
@global_rate_limit()
async def leaderboard_slash(interaction: discord.Interaction, top_n: int = 10):
    await interaction.response.defer()
    if top_n <= 0: top_n = 10
    if top_n > 25: top_n = 25
    try:
        response = supabase.table('profiles').select('user_id', 'balance').order('balance', desc=True).limit(top_n).execute()
        if not response.data: await interaction.followup.send('Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng.'); return
        embed = discord.Embed(title=f"üèÜ B·∫£ng X·∫øp H·∫°ng {top_n} ƒê·∫°i Gia üèÜ", color=discord.Color.gold()); rank_count = 1
        for user_data in response.data:
             user_mention = f"<@{user_data['user_id']}>" # T·∫°o mention string
             embed.add_field(name=f"#{rank_count}: {user_mention}", value=f"**{user_data.get('balance', 0):,}** ü™ô", inline=False); rank_count += 1
        await interaction.followup.send(embed=embed)
    except Exception as e: await interaction.followup.send(f'L·ªói khi l·∫•y b·∫£ng x·∫øp h·∫°ng: {e}', ephemeral=True)

@bot.slash_command(name="chuyenxu", description="Chuy·ªÉn token cho ng∆∞·ªùi d√πng kh√°c.")
@app_commands.describe(recipient="Ng∆∞·ªùi b·∫°n mu·ªën chuy·ªÉn token ƒë·∫øn", amount="S·ªë l∆∞·ª£ng token mu·ªën chuy·ªÉn")
@global_rate_limit()
@is_user_not_in_game()
async def transfer_tokens_slash(interaction: discord.Interaction, recipient: discord.Member, amount: int):
    await interaction.response.defer()
    sender_id = interaction.user.id; recipient_id = recipient.id
    if sender_id == recipient_id: await interaction.followup.send('B·∫°n kh√¥ng th·ªÉ t·ª± chuy·ªÉn cho ch√≠nh m√¨nh!', ephemeral=True); return
    if amount <= 0: await interaction.followup.send('S·ªë ti·ªÅn chuy·ªÉn ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    sender_data = get_user_data(sender_id)
    if not sender_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu ng∆∞·ªùi g·ª≠i.", ephemeral=True); return
    if sender_data.get('balance', 0) < amount: await interaction.followup.send(f'B·∫°n kh√¥ng ƒë·ªß ti·ªÅn. B·∫°n ch·ªâ c√≥ **{sender_data.get("balance", 0):,}** ü™ô.', ephemeral=True); return
    # Th·ª±c hi·ªán chuy·ªÉn ti·ªÅn (c·∫ßn ƒë·∫£m b·∫£o c·∫£ hai update th√†nh c√¥ng - transaction l√Ω t∆∞·ªüng nh·∫•t)
    sender_new_balance = update_balance(sender_id, -amount)
    if sender_new_balance is None: await interaction.followup.send("L·ªói khi tr·ª´ ti·ªÅn ng∆∞·ªùi g·ª≠i!", ephemeral=True); return # B√°o l·ªói n·∫øu tr·ª´ ti·ªÅn th·∫•t b·∫°i
    recipient_new_balance = update_balance(recipient_id, amount)
    if recipient_new_balance is None:
        # L·ªói c·ªông ti·ªÅn ng∆∞·ªùi nh·∫≠n -> Ho√†n ti·ªÅn ng∆∞·ªùi g·ª≠i
        update_balance(sender_id, amount) # C·ªë g·∫Øng ho√†n ti·ªÅn
        await interaction.followup.send("L·ªói khi c·ªông ti·ªÅn ng∆∞·ªùi nh·∫≠n! Giao d·ªãch b·ªã h·ªßy.", ephemeral=True); return
    await interaction.followup.send(f'‚úÖ {interaction.user.mention} ƒë√£ chuy·ªÉn **{amount:,}** ü™ô cho {recipient.mention}!')

@bot.slash_command(name="profile", description="Xem h·ªì s∆° c·ªßa b·∫°n ho·∫∑c ng∆∞·ªùi kh√°c.")
@app_commands.describe(member="Ng∆∞·ªùi d√πng b·∫°n mu·ªën xem h·ªì s∆° (ƒë·ªÉ tr·ªëng n·∫øu l√† b·∫°n)")
@global_rate_limit()
async def profile_slash(interaction: discord.Interaction, member: typing.Optional[discord.Member]):
    await interaction.response.defer()
    target_user = member or interaction.user; user_data = get_user_data(target_user.id)
    if not user_data: await interaction.followup.send(f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho {target_user.mention}."); return
    balance = user_data.get('balance', 0); total_bet = user_data.get('total_bet', 0); total_won = user_data.get('total_won', 0); games_played = user_data.get('games_played', 0)
    net_profit = total_won - total_bet; streak = user_data.get('daily_streak', 0)
    embed = discord.Embed(title=f"üìä H·ªì s∆° c·ªßa {target_user.display_name}", color=target_user.color); embed.set_thumbnail(url=target_user.display_avatar.url)
    embed.add_field(name="üí∞ S·ªë d∆∞", value=f"**{balance:,}** ü™ô", inline=True); embed.add_field(name="üî• Chu·ªói Daily", value=f"{streak} ng√†y", inline=True); embed.add_field(name="üé≤ S·ªë game ƒë√£ ch∆°i", value=f"{games_played:,}", inline=True)
    embed.add_field(name="üìà T·ªïng c∆∞·ª£c", value=f"{total_bet:,} ü™ô", inline=False); embed.add_field(name="üèÜ T·ªïng l·ªùi", value=f"{total_won:,} ü™ô", inline=False)
    embed.add_field(name="üíπ L√£i/L·ªó r√≤ng", value=f"**{net_profit:,}** ü™ô", inline=False)
    await interaction.followup.send(embed=embed)


# --- L·ªÜNH ADMIN (SLASH COMMANDS) ---
admin_group = app_commands.Group(name="admin", description="C√°c l·ªánh qu·∫£n l√Ω bot", guild_only=True, default_permissions=discord.Permissions(manage_guild=True)) # Ch·ªâ ng∆∞·ªùi c√≥ quy·ªÅn Manage Server th·∫•y?

@admin_group.command(name="give", description="C·ªông/Tr·ª´ token cho ng∆∞·ªùi d√πng.")
@app_commands.checks.has_role(ADMIN_ROLE) # V·∫´n check role c·ª• th·ªÉ
@global_rate_limit()
async def admin_give_slash(interaction: discord.Interaction, member: discord.Member, amount: int):
    await interaction.response.defer(ephemeral=True)
    if amount == 0: await interaction.followup.send("S·ªë l∆∞·ª£ng ph·∫£i kh√°c 0."); return
    user_id = member.id; new_balance = update_balance(user_id, amount)
    if new_balance is None: await interaction.followup.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    action = "c·ªông" if amount > 0 else "tr·ª´"; abs_amount = abs(amount)
    await interaction.followup.send(f"‚úÖ ƒê√£ {action} **{abs_amount:,}** ü™ô cho {member.mention}. S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.")

@admin_group.command(name="set", description="ƒê·∫∑t s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng v·ªÅ m·ªôt con s·ªë c·ª• th·ªÉ.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_set_slash(interaction: discord.Interaction, member: discord.Member, amount: int):
    await interaction.response.defer(ephemeral=True)
    if amount < 0: await interaction.followup.send("Kh√¥ng th·ªÉ set s·ªë d∆∞ √¢m."); return
    try: supabase.rpc('set_balance', {'user_id_input': member.id, 'amount_input': amount}).execute(); await interaction.followup.send(f"‚úÖ ƒê√£ set s·ªë d∆∞ c·ªßa {member.mention} th√†nh **{amount:,}** ü™ô.")
    except Exception as e: await interaction.followup.send(f"ƒê√£ x·∫£y ra l·ªói khi set balance: {e}")

@admin_group.command(name="createcode", description="T·∫°o m·ªôt giftcode m·ªõi.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_createcode_slash(interaction: discord.Interaction, code: str, reward: int):
    await interaction.response.defer(ephemeral=True)
    if reward <= 0: await interaction.followup.send("Ph·∫ßn th∆∞·ªüng ph·∫£i l·ªõn h∆°n 0."); return
    code = code.upper()
    try: supabase.table('gift_codes').insert({'code': code, 'reward': reward}).execute(); await interaction.followup.send(f"‚úÖ ƒê√£ t·∫°o giftcode `{code}` tr·ªã gi√° **{reward:,}** ü™ô.")
    except Exception as e: await interaction.followup.send(f"L·ªói! Code `{code}` c√≥ th·ªÉ ƒë√£ t·ªìn t·∫°i. ({e})")

@admin_group.command(name="deletecode", description="X√≥a m·ªôt giftcode.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_deletecode_slash(interaction: discord.Interaction, code: str):
    await interaction.response.defer(ephemeral=True)
    code = code.upper()
    try: response = supabase.table('gift_codes').delete().eq('code', code).execute()
    except Exception as e: await interaction.followup.send(f"ƒê√£ x·∫£y ra l·ªói khi x√≥a code: {e}"); return
    if response.data: await interaction.followup.send(f"‚úÖ ƒê√£ x√≥a th√†nh c√¥ng giftcode `{code}`.")
    else: await interaction.followup.send(f"L·ªói! Kh√¥ng t√¨m th·∫•y giftcode n√†o t√™n l√† `{code}`.")

@admin_group.command(name="view", description="Xem chi ti·∫øt th√¥ng tin c·ªßa ng∆∞·ªùi d√πng.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_view_slash(interaction: discord.Interaction, member: discord.Member):
    await interaction.response.defer(ephemeral=True)
    user_data = get_user_data(member.id)
    if not user_data: await interaction.followup.send("Kh√¥ng t√¨m th·∫•y user."); return
    embed = discord.Embed(title=f"üëÄ Xem th√¥ng tin: {member.display_name}", color=member.color)
    for key, value in user_data.items():
        if key == 'used_codes' and isinstance(value, list): embed.add_field(name=key, value=f"`{'`, `'.join(value)}`" if value else "Ch∆∞a d√πng code n√†o", inline=False)
        elif key == 'last_daily' and value:
             try: dt_object = datetime.fromisoformat(value).astimezone(VIETNAM_TZ); embed.add_field(name=key, value=f"{dt_object.strftime('%Y-%m-%d %H:%M:%S %Z')}", inline=False)
             except: embed.add_field(name=key, value=f"`{value}` (L·ªói format)", inline=False)
        elif key == 'last_streak_date' and value:
             try: dt_object = date.fromisoformat(value); embed.add_field(name=key, value=f"{dt_object.strftime('%Y-%m-%d')}", inline=False)
             except: embed.add_field(name=key, value=f"`{value}` (L·ªói format)", inline=False)
        elif isinstance(value, (int, float)): embed.add_field(name=key, value=f"`{value:,}`", inline=False)
        else: embed.add_field(name=key, value=f"`{value}`", inline=False)
    await interaction.followup.send(embed=embed)

@admin_group.command(name="resetdaily", description="Reset th·ªùi gian daily v√† streak cho ng∆∞·ªùi d√πng.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_resetdaily_slash(interaction: discord.Interaction, member: discord.Member):
    await interaction.response.defer(ephemeral=True)
    try: supabase.table('profiles').update({'last_daily': None, 'last_streak_date': None, 'daily_streak': 0}).eq('user_id', member.id).execute(); await interaction.followup.send(f"‚úÖ ƒê√£ reset th·ªùi gian `daily` v√† streak cho {member.mention}.")
    except Exception as e: await interaction.followup.send(f"L·ªói khi reset daily: {e}")

@admin_group.command(name="announce", description="G·ª≠i th√¥ng b√°o t·ªõi k√™nh ch·ªâ ƒë·ªãnh.")
@app_commands.checks.has_role(ADMIN_ROLE)
@app_commands.describe(channel="K√™nh mu·ªën g·ª≠i th√¥ng b√°o", message="N·ªôi dung th√¥ng b√°o")
@global_rate_limit()
async def admin_announce_slash(interaction: discord.Interaction, channel: discord.TextChannel, message: str):
    await interaction.response.defer(ephemeral=True)
    try: embed = discord.Embed(title="üì¢ Th√¥ng B√°o T·ª´ Admin üì¢", description=message, color=discord.Color.orange()); embed.set_footer(text=f"G·ª≠i b·ªüi {interaction.user.display_name}"); await channel.send(embed=embed); await interaction.followup.send("‚úÖ ƒê√£ g·ª≠i th√¥ng b√°o.")
    except Exception as e: await interaction.followup.send(f"L·ªói khi g·ª≠i th√¥ng b√°o: {e}")

bot.tree.add_command(admin_group) # ƒêƒÉng k√Ω nh√≥m l·ªánh admin


# --- GAME 24/7: T√ÄI X·ªàU (UI) ---
# (Class BetModal, TaiXiuGameView, get_bet_totals, tai_xiu_game_loop gi·ªØ nguy√™n nh∆∞ user_19/user_21)
# ... D√°n code BetModal ...
# ... D√°n code TaiXiuGameView ...
# ... D√°n code get_bet_totals ...
# ... D√°n code @tasks.loop tai_xiu_game_loop (bao g·ªìm x·ª≠ l√Ω n·ªï h≈©) ...
# ... D√°n code @tai_xiu_game_loop.before_loop ...

# (L·ªánh start/stop d√πng Slash Commands, start kh√¥ng c·∫ßn role)
@bot.slash_command(name="start_taixiu", description="B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p game T√†i X·ªâu 24/7 t·∫°i k√™nh n√†y.")
@global_rate_limit()
async def start_taixiu_slash(interaction: discord.Interaction):
    global game_channel_id
    if game_channel_id and game_channel_id != interaction.channel_id and tai_xiu_game_loop.is_running():
        await interaction.response.send_message(f"Game T√†i X·ªâu ƒë√£ ch·∫°y ·ªü k√™nh <#{game_channel_id}> r·ªìi!", ephemeral=True)
        return
    game_channel_id = interaction.channel_id
    if not tai_xiu_game_loop.is_running():
        tai_xiu_game_loop.start()
        await interaction.response.send_message(f"‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu Game T√†i X·ªâu 24/7 t·∫°i k√™nh <#{game_channel_id}>.")
    else:
        await interaction.response.send_message(f"Game ƒë√£ ch·∫°y t·∫°i k√™nh <#{game_channel_id}> r·ªìi.", ephemeral=True)

@bot.slash_command(name="stop_taixiu", description="(ADMIN) D·ª´ng v√≤ng l·∫∑p game T√†i X·ªâu.")
@app_commands.checks.has_role(ADMIN_ROLE) # V·∫´n c·∫ßn admin ƒë·ªÉ d·ª´ng
@global_rate_limit()
async def stop_taixiu_slash(interaction: discord.Interaction):
    global game_channel_id
    if tai_xiu_game_loop.is_running():
        tai_xiu_game_loop.stop()
        await interaction.response.send_message("‚úÖ ƒê√£ d·ª´ng Game T√†i X·ªâu.")
        await asyncio.sleep(1) # ƒê·ª£i loop th·ª±c s·ª± d·ª´ng
        game_channel_id = None
        current_bets = {} # X√≥a c∆∞·ª£c c√≤n l·∫°i
        if game_message: # X√≥a tin nh·∫Øn game c≈© n·∫øu c√≥
            try: await game_message.delete()
            except: pass
            game_message = None
    else:
        await interaction.response.send_message("Game ch∆∞a ch·∫°y.", ephemeral=True)


# --- GAME THEO L·ªÜNH (SLASH COMMANDS, C√ì HI·ªÜU ·ª®NG V√Ä KH√ìA) ---
# (Chuy·ªÉn ƒë·ªïi !slots, !hilo, !tungxu, !xucxac, !baucua, !duangua, !quay, !baccarat sang Slash)
# V√≠ d·ª• cho slots:
@bot.slash_command(name="slots", description="Ch∆°i m√°y x√®ng.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn b·∫°n mu·ªën c∆∞·ª£c")
@global_rate_limit()
@is_user_not_in_game()
async def slots_slash(interaction: discord.Interaction, bet_amount: int):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer() # Quan tr·ªçng: b√°o Discord ch·ªù
    try:
        final_results = random.choices(SLOT_WHEEL, weights=SLOT_WEIGHTS, k=3)
        embed = discord.Embed(title="üé∞ M√°y X√®ng üé∞", description="| - | - | - |", color=discord.Color.blue())
        embed.set_footer(text=f"{interaction.user.display_name} ƒë√£ c∆∞·ª£c {bet_amount:,} ü™ô")
        slot_message = await interaction.followup.send(embed=embed, wait=True) # D√πng followup

        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | - | - |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | {final_results[1]} | - |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | {final_results[1]} | {final_results[2]} |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")

        winnings = 0; jackpot_win = 0; is_jackpot = (final_results[0] == final_results[1] == final_results[2] == '7Ô∏è‚É£')
        if is_jackpot:
            jackpot_pool = get_jackpot_pool('slots'); winnings = jackpot_pool; jackpot_win = winnings
            embed.description += f"\n\n**üí•üí•üí• JACKPOT TI·∫æN TRI·ªÇN!!! üí•üí•üí•**"; update_jackpot_pool('slots', -jackpot_pool); update_jackpot_pool('slots', 1000) # Reset v·ªÅ 1000
        elif final_results[0] == final_results[1] == final_results[2]:
            payout = SLOT_PAYOUTS[final_results[0]]; winnings = bet_amount * payout
            embed.description += f"\n\n**JACKPOT!** B·∫°n tr√∫ng 3x {final_results[0]} (1 ƒÉn {payout})!"
        elif final_results[0] == final_results[1] or final_results[1] == final_results[2]:
            matching_symbol = final_results[1]; winnings = bet_amount * 1 # Ch·ªâ tr·∫£ 1:1 cho 2x
            embed.description += f"\n\nB·∫°n tr√∫ng 2x {matching_symbol} (1 ƒÉn 1)!"

        jackpot_contrib = int(bet_amount * 0.01) if not is_jackpot and bet_amount > 0 else 0 # Ch·ªâ contrib n·∫øu c∆∞·ª£c > 0
        if jackpot_contrib > 0: update_jackpot_pool('slots', jackpot_contrib)
        net_gain = winnings if is_jackpot else (winnings - jackpot_contrib if winnings > 0 else -(bet_amount - jackpot_contrib)) # T√≠nh net gain/loss ch√≠nh x√°c h∆°n
        new_balance = update_balance(user_id, net_gain)
        update_profile_stats(user_id, bet_amount, net_gain)

        if winnings > 0: embed.description += f"\nüéâ B·∫°n th·∫Øng **{winnings:,}** ü™ô!\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description += f"\n\nüò¢ Ch√∫c may m·∫Øn l·∫ßn sau.\nB·∫°n m·∫•t **{bet_amount:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        current_jackpot = get_jackpot_pool('slots'); embed.add_field(name="üí∞ Jackpot Slots Hi·ªán T·∫°i", value=f"**{current_jackpot:,}** ü™ô", inline=False)

        try: await slot_message.edit(embed=embed)
        except discord.NotFound: await interaction.followup.send(embed=embed) # G·ª≠i l·∫°i n·∫øu b·ªã x√≥a

    except asyncio.CancelledError: await interaction.followup.send("Tr√≤ ch∆°i b·ªã h·ªßy do tin nh·∫Øn b·ªã x√≥a.", ephemeral=True)
    except Exception as e: print(f"L·ªói /slots: {e}"); await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ch∆°i Slots.", ephemeral=True)
    finally: bot.users_in_animation.discard(user_id)

# ... (T∆∞∆°ng t·ª± chuy·ªÉn ƒë·ªïi /hilo, /tungxu, /xucxac, /baucua, /duangua, /quay, /baccarat) ...

# --- X·ªî S·ªê (LOTTERY) - SLASH COMMANDS & TASK ---
# ... (D√°n code lottery_group v√† lottery_draw_task ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi) ...

# --- ƒêO√ÅN S·ªê (GUESS THE NUMBER) - SLASH COMMANDS ---
# ... (D√°n code Class GuessTheNumberGame v√† guess_group ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi) ...

# --- GAME GIAO DI·ªÜN UI (BLACKJACK & MINES) - SLASH COMMANDS ---
# ... (D√°n code Blackjack v√† Mines ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi sang Slash Commands) ...

# --- V√íNG QUAY MAY M·∫ÆN (SPIN THE WHEEL) - SLASH COMMAND ---
# ... (D√°n code Spin the Wheel ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi sang Slash Commands) ...

# --- CH·∫†Y BOT ---
if __name__ == "__main__":
    if TOKEN:
        keep_alive();
        try: bot.run(TOKEN)
        except Exception as e: print(f"L·ªói khi ch·∫°y bot: {e}")
    else:
        print("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_TOKEN")
