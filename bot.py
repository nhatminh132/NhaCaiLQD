# -*- coding: utf-8 -*-
import discord
from discord.ext import commands, tasks
from discord import ui, app_commands # S·ª≠ d·ª•ng app_commands cho slash
import os
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone, date, time
from supabase import create_client, Client
import typing
import random
import asyncio
import math
import discord.utils
import pytz # Th√™m th∆∞ vi·ªán m√∫i gi·ªù
import re # Th√™m th∆∞ vi·ªán regex cho c∆∞·ª£c Roulette ph·ª©c t·∫°p

# Import t·ªáp keep_alive
from keep_alive import keep_alive

# --- T·∫£i Token v√† C√†i ƒë·∫∑t Bot ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_KEY = os.getenv('SUPABASE_KEY')

# --- C√†i ƒë·∫∑t Supabase ---
if not SUPABASE_URL or not SUPABASE_KEY: print("L·ªñI: Kh√¥ng t√¨m th·∫•y SUPABASE_URL ho·∫∑c SUPABASE_KEY"); exit()
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# --- C√†i ƒë·∫∑t Bot Discord (S·ª¨ D·ª§NG discord.Bot cho Slash Commands) ---
intents = discord.Intents.default()
# intents.message_content = True # C√≥ th·ªÉ b·∫≠t n·∫øu c·∫ßn ƒë·ªçc tin nh·∫Øn th∆∞·ªùng cho t√≠nh nƒÉng kh√°c
intents.members = True # C·∫ßn ƒë·ªÉ l·∫•y th√¥ng tin Member
bot = discord.Bot(intents=intents) # S·ª≠ d·ª•ng discord.Bot

# --- BI·∫æN TO√ÄN C·ª§C CHO GAME ---
game_message = None # Tin nh·∫Øn game T√†i X·ªâu
game_channel_id = None # K√™nh game T√†i X·ªâu
current_bets = {} # C∆∞·ª£c v√°n T√†i X·ªâu hi·ªán t·∫°i
bot.blackjack_games = {} # L∆∞u c√°c v√°n Blackjack
bot.mines_games = {} # L∆∞u c√°c v√°n D√≤ M√¨n
bot.users_in_animation = set() # D√πng ƒë·ªÉ kh√≥a l·ªánh khi game c√≥ hi·ªáu ·ª©ng
bot.guess_the_number_game = None # L∆∞u state game ƒêo√°n S·ªë
bot.spin_the_wheel_games = {} # L∆∞u c√°c v√°n V√≤ng Quay May M·∫Øn

# --- ƒê·ªäNH NGHƒ®A H·∫∞NG S·ªê ---
STARTING_TOKENS = 100
DAILY_REWARD = 50
DAILY_COOLDOWN_HOURS = 24
ADMIN_ROLE = "Bot Admin" # V·∫´n c·∫ßn cho c√°c l·ªánh admin kh√°c
VIETNAM_TZ = pytz.timezone('Asia/Ho_Chi_Minh')
LOTTERY_DRAW_TIME = time(18, 0, 0, tzinfo=VIETNAM_TZ)
LOTTERY_TICKET_PRICE = 100

# Roulette
RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]
BLACK_NUMBERS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35]
ROULETTE_PAYOUTS = {'single': 35, 'split': 17, 'street': 11, 'corner': 8, 'sixline': 5, 'dozen': 2, 'column': 2, 'color': 1, 'evenodd': 1, 'half': 1}

# B·∫ßu Cua
BAU_CUA_FACES = {'b·∫ßu': 'B·∫ßu üçê', 'bau': 'B·∫ßu üçê', 'üçê': 'B·∫ßu üçê', 'cua': 'Cua ü¶Ä', 'ü¶Ä': 'Cua ü¶Ä', 't√¥m': 'T√¥m ü¶ê', 'tom': 'T√¥m ü¶ê', 'ü¶ê': 'T√¥m ü¶ê', 'c√°': 'C√° üêü', 'ca': 'C√° üêü', 'üêü': 'C√° üêü', 'g√†': 'G√† üêì', 'ga': 'G√† üêì', 'üêì': 'G√† üêì', 'nai': 'Nai ü¶å', 'ü¶å': 'Nai ü¶å'}
BAU_CUA_LIST = ['B·∫ßu üçê', 'Cua ü¶Ä', 'T√¥m ü¶ê', 'C√° üêü', 'G√† üêì', 'Nai ü¶å']

# ƒêua Ng·ª±a
NUM_HORSES = 6; RACE_LENGTH = 20

# M√°y X√®ng (Slots)
SLOT_SYMBOLS = [('üçí', 10, 10), ('üçã', 9, 15), ('üçä', 8, 20), ('üçì', 5, 30), ('üîî', 3, 50), ('üíé', 2, 100), ('7Ô∏è‚É£', 1, 200)]
SLOT_WHEEL, SLOT_WEIGHTS, SLOT_PAYOUTS = [], [], {}
for (symbol, weight, payout) in SLOT_SYMBOLS: SLOT_WHEEL.append(symbol); SLOT_WEIGHTS.append(weight); SLOT_PAYOUTS[symbol] = payout

# B√†i (Cards)
CARD_SUITS = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è']
# J=10, Q=10, K=10, A=1 (Baccarat), A=11/1 (BJ), A=14 (Hilo)
CARD_RANKS_BACCARAT = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 0, 'J': 0, 'Q': 0, 'K': 0, 'A': 1}
CARD_RANKS_BJ = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
CARD_RANKS_HILO = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}

# V√≤ng Quay May M·∫Øn
WHEEL_SEGMENTS = [('0.5x', 15, 0.5), ('1x', 20, 1.0), ('1.5x', 10, 1.5), ('2x', 8, 2.0), ('3x', 5, 3.0), ('5x', 3, 5.0), ('10x', 1, 10.0), ('üí£ M·∫•t', 10, 0.0)]
WHEEL_OPTIONS, WHEEL_WEIGHTS = [], []
for (label, weight, value) in WHEEL_SEGMENTS: WHEEL_OPTIONS.append((label, value)); WHEEL_WEIGHTS.append(weight)

# --- C√ÄI ƒê·∫∂T RATE LIMIT TO√ÄN C·ª§C ---
def global_rate_limit():
    async def predicate(interaction: discord.Interaction):
        # Kh√¥ng c·∫ßn check help v√¨ kh√¥ng c√≤n l·ªánh help
        bucket = global_cooldown.get_bucket(interaction)
        retry_after = bucket.update_rate_limit()
        if retry_after:
            raise app_commands.CommandOnCooldown(bucket, retry_after)
        return True
    return app_commands.check(predicate)

global_cooldown = commands.CooldownMapping.from_cooldown(30, 60.0, commands.BucketType.default)


# --- QU·∫¢N L√ù D·ªÆ LI·ªÜU (SUPABASE) ---
def get_user_data(user_id: int) -> typing.Dict:
    try:
        response = supabase.table('profiles').select('*').eq('user_id', user_id).single().execute()
        data = response.data
        if not data: raise Exception("User not found initially") # N√©m l·ªói n·∫øu single() tr·∫£ v·ªÅ None
        # ƒê·∫£m b·∫£o c√°c c·ªôt t·ªìn t·∫°i v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu thi·∫øu
        data.setdefault('balance', STARTING_TOKENS)
        data.setdefault('last_daily', None)
        data.setdefault('used_codes', [])
        data.setdefault('total_bet', 0)
        data.setdefault('total_won', 0)
        data.setdefault('games_played', 0)
        data.setdefault('daily_streak', 0)
        data.setdefault('last_streak_date', None)
        return data
    except Exception as e:
        if "JSON object requested" in str(e) or "User not found initially" in str(e): # User ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
             try:
                 insert_response = supabase.table('profiles').insert({'user_id': user_id, 'balance': STARTING_TOKENS, 'last_daily': None, 'used_codes': [], 'total_bet': 0, 'total_won': 0, 'games_played': 0, 'daily_streak': 0, 'last_streak_date': None}).execute()
                 return insert_response.data[0]
             except Exception as e2: print(f"L·ªói khi t·∫°o user m·ªõi {user_id}: {e2}"); return None
        else: print(f"L·ªói khi get_user_data cho {user_id}: {e}"); return None

def update_balance(user_id: int, amount: int) -> typing.Optional[int]:
    try:
        # G·ªçi RPC function ƒë√£ t·∫°o trong Supabase
        response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
        return response.data # Tr·∫£ v·ªÅ s·ªë d∆∞ m·ªõi
    except Exception as e:
        print(f"L·ªói khi update_balance cho {user_id}: {e}")
        # N·∫øu l·ªói c√≥ th·ªÉ do user ch∆∞a t·ªìn t·∫°i, th·ª≠ t·∫°o/l·∫•y l·∫°i
        user_data = get_user_data(user_id)
        if user_data: # N·∫øu user t·ªìn t·∫°i (ho·∫∑c v·ª´a ƒë∆∞·ª£c t·∫°o), th·ª≠ g·ªçi RPC l·∫°i
             try:
                 response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
                 return response.data
             except Exception as e2: print(f"L·ªói l·∫ßn 2 khi update_balance: {e2}")
        return None # Tr·∫£ v·ªÅ None n·∫øu v·∫´n l·ªói

def update_profile_stats(user_id: int, bet_amount: int, net_gain: int):
    try:
        user_data = get_user_data(user_id) # L·∫•y data ƒë·ªÉ ƒë·∫£m b·∫£o c√≥ gi√° tr·ªã m·∫∑c ƒë·ªãnh
        if not user_data: return

        new_total_bet = user_data.get('total_bet', 0) + bet_amount
        new_total_won = user_data.get('total_won', 0) + max(0, net_gain) # Ch·ªâ c·ªông ph·∫ßn l·ªùi
        new_games_played = user_data.get('games_played', 0) + 1

        supabase.table('profiles').update({
            'total_bet': new_total_bet,
            'total_won': new_total_won,
            'games_played': new_games_played
        }).eq('user_id', user_id).execute()
    except Exception as e: print(f"L·ªói khi update_profile_stats cho {user_id}: {e}")

def get_jackpot_pool(game_name: str):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        response = supabase.table(table_name).select('pool_amount').eq('game_name', game_name).maybe_single().execute()
        return response.data['pool_amount'] if response.data else 0
    except Exception as e: print(f"L·ªói khi l·∫•y jackpot {game_name}: {e}"); return 0

def update_jackpot_pool(game_name: str, amount: int):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        # S·ª≠ d·ª•ng atomic increment/decrement n·∫øu c√≥ th·ªÉ (v√≠ d·ª• qua RPC)
        # T·∫°m th·ªùi v·∫´n ƒë·ªçc-ghi
        current_pool = get_jackpot_pool(game_name)
        new_pool = max(0, current_pool + amount) # ƒê·∫£m b·∫£o h≈© kh√¥ng √¢m
        supabase.table(table_name).update({'pool_amount': new_pool}).eq('game_name', game_name).execute()
        return new_pool
    except Exception as e: print(f"L·ªói khi c·∫≠p nh·∫≠t jackpot {game_name}: {e}"); return get_jackpot_pool(game_name)

def get_taixiu_history():
    try:
        response = supabase.table('jackpot').select('history').eq('game_name', 'taixiu').maybe_single().execute()
        return response.data.get('history', [])[-10:] if response.data else []
    except Exception as e: print(f"Loi khi lay history taixiu: {e}"); return []


# --- H√ÄM KI·ªÇM TRA & S·ª∞ KI·ªÜN BOT ---
@bot.event
async def on_ready():
    # ƒêƒÉng k√Ω View persistent cho T√†i X·ªâu ƒë·ªÉ n√∫t ho·∫°t ƒë·ªông sau khi bot kh·ªüi ƒë·ªông l·∫°i
    bot.add_view(TaiXiuGameView())
    # Kh·ªüi ƒë·ªông task x·ªï s·ªë
    if not lottery_draw_task.is_running():
        lottery_draw_task.start()
    print(f'Bot {bot.user.name} ({bot.user.id}) ƒë√£ s·∫µn s√†ng!')
    # ƒê·ªìng b·ªô h√≥a Slash Commands
    try:
        synced = await bot.tree.sync()
        print(f"ƒê√£ ƒë·ªìng b·ªô h√≥a {len(synced)} l·ªánh ·ª©ng d·ª•ng.")
    except Exception as e:
        print(f"L·ªói khi ƒë·ªìng b·ªô h√≥a l·ªánh: {e}")
    print('------')

@bot.event
async def on_application_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    command_name = interaction.command.name if interaction.command else "Unknown"
    original_error = getattr(error, 'original', error)

    async def safe_response(content: str, ephemeral: bool = True, delete_after: typing.Optional[int] = None):
        try:
            if interaction.response.is_done(): await interaction.followup.send(content, ephemeral=ephemeral, delete_after=delete_after)
            else: await interaction.response.send_message(content, ephemeral=ephemeral, delete_after=delete_after)
        except discord.InteractionResponded:
            try: await interaction.followup.send(content, ephemeral=ephemeral, delete_after=delete_after)
            except Exception as e_inner: print(f"L·ªói g·ª≠i followup sau InteractionResponded: {e_inner}")
        except Exception as e_outer: print(f"L·ªói g·ª≠i ph·∫£n h·ªìi l·ªói chung: {e_outer}")

    if isinstance(error, app_commands.CommandOnCooldown):
        seconds = error.retry_after; await safe_response(f"‚è≥ Bot ƒëang x·ª≠ l√Ω qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng th·ª≠ l·∫°i sau **{seconds:.1f} gi√¢y**.", delete_after=5)
    elif isinstance(error, app_commands.MissingRole):
        await safe_response(f"R·∫•t ti·∫øc {interaction.user.mention}, b·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y. C·∫ßn role `{ADMIN_ROLE}`.")
    elif isinstance(error, app_commands.CheckFailure):
         await safe_response(f"‚è≥ {interaction.user.mention}, b·∫°n ƒëang c√≥ m·ªôt tr√≤ ch∆°i kh√°c ƒëang ch·∫°y ho·∫∑c kh√¥ng th·ªÉ th·ª±c hi·ªán l·ªánh n√†y ngay b√¢y gi·ªù.", delete_after=5)
    elif isinstance(error, app_commands.CommandInvokeError):
        if isinstance(original_error, ValueError) and "Invalid Roulette bet type" in str(original_error):
             bet_arg = interaction.data.get('options', [{}])[0].get('options', [{}])[-1].get('value', 'kh√¥ng r√µ')
             await safe_response(f"Lo·∫°i c∆∞·ª£c Roulette kh√¥ng h·ª£p l·ªá: `{bet_arg}`. G√µ `/` xem v√≠ d·ª•.")
        else:
            print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ l·ªánh '{command_name}': {original_error}")
            await safe_response('ƒê√£ x·∫£y ra l·ªói b√™n trong l·ªánh. Vui l√≤ng th·ª≠ l·∫°i sau.')
    elif isinstance(error, app_commands.TransformerError) or isinstance(error, app_commands.ArgumentParsingError):
         await safe_response(f'Tham s·ªë b·∫°n nh·∫≠p cho l·ªánh `{command_name}` kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.')
    else:
        print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ l·ªánh '{command_name}': {error}")
        await safe_response('ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh.')

# --- H√ÄM KI·ªÇM TRA GAME ƒêANG CH·∫†Y (CHO SLASH COMMANDS) ---
def is_user_not_in_game():
    async def predicate(interaction: discord.Interaction):
        user_id = interaction.user.id
        if user_id in bot.blackjack_games: return False
        if user_id in bot.mines_games: return False
        if user_id in bot.spin_the_wheel_games: return False
        # Cho ph√©p ƒëo√°n khi game ƒëo√°n s·ªë ƒëang ch·∫°y
        is_guessing = interaction.command and interaction.command.name == "guess" and interaction.command.parent and interaction.command.parent.name == "guess"
        if bot.guess_the_number_game and user_id in bot.guess_the_number_game.participants and not is_guessing:
             return False
        if user_id in bot.users_in_animation: return False
        return True
    return app_commands.check(predicate)

# --- L·ªÜNH SLASH COMMANDS ---

# --- L·ªÜNH C∆† B·∫¢N V√Ä X√É H·ªòI ---
@bot.slash_command(name="kiemtra", description="Ki·ªÉm tra s·ªë d∆∞ token ü™ô hi·ªán t·∫°i c·ªßa b·∫°n.")
@global_rate_limit()
async def balance_check_slash(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    user_data = get_user_data(interaction.user.id)
    await interaction.followup.send(f'ü™ô {interaction.user.mention}, b·∫°n ƒëang c√≥ **{user_data.get("balance", 0):,}** token.' if user_data else 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y s·ªë d∆∞ c·ªßa b·∫°n.')

@bot.slash_command(name="daily", description="Nh·∫≠n th∆∞·ªüng token h√†ng ng√†y v√† duy tr√¨ chu·ªói ƒëƒÉng nh·∫≠p.")
@global_rate_limit()
@is_user_not_in_game()
async def daily_reward_slash(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return

    can_claim = True; time_left_str = ""; current_streak = user_data.get('daily_streak', 0); last_streak_date_str = user_data.get('last_streak_date'); today = datetime.now(VIETNAM_TZ).date(); yesterday = today - timedelta(days=1)
    if user_data.get('last_daily'):
        try: last_daily_time = datetime.fromisoformat(user_data['last_daily']); cooldown = timedelta(hours=DAILY_COOLDOWN_HOURS)
        except: last_daily_time = None
        if last_daily_time and datetime.now(timezone.utc) < last_daily_time + cooldown:
            time_left = (last_daily_time + cooldown) - datetime.now(timezone.utc); hours_left = int(time_left.total_seconds() // 3600); minutes_left = int((time_left.total_seconds() % 3600) // 60)
            time_left_str = f'B·∫°n c·∫ßn ch·ªù **{hours_left} gi·ªù {minutes_left} ph√∫t** n·ªØa.'
            can_claim = False
    if not can_claim: await interaction.followup.send(f'{interaction.user.mention}, {time_left_str}'); return

    new_streak = 0; streak_bonus = 0
    if last_streak_date_str:
        try: last_streak_date = date.fromisoformat(last_streak_date_str)
        except: last_streak_date = None
        if last_streak_date == today: new_streak = current_streak
        elif last_streak_date == yesterday: new_streak = current_streak + 1
        else: new_streak = 1
    else: new_streak = 1
    streak_bonus = min(new_streak * 10, 100); total_reward = DAILY_REWARD + streak_bonus
    new_balance = update_balance(user_id, total_reward)
    if new_balance is None: await interaction.followup.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try:
        supabase.table('profiles').update({'last_daily': datetime.now(timezone.utc).isoformat(), 'daily_streak': new_streak, 'last_streak_date': str(today)}).eq('user_id', user_id).execute()
        streak_msg = f"üî• Chu·ªói ƒëƒÉng nh·∫≠p: **{new_streak} ng√†y** (+{streak_bonus}ü™ô bonus)!" if new_streak > 1 else "üî• B·∫Øt ƒë·∫ßu chu·ªói ƒëƒÉng nh·∫≠p!"
        await interaction.followup.send(f'üéâ {interaction.user.mention}, b·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **{total_reward}** token ({DAILY_REWARD} + {streak_bonus} bonus)! {streak_msg}\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await interaction.followup.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t th·ªùi gian/streak: {e}')

@bot.slash_command(name="code", description="Nh·∫≠p giftcode ƒë·ªÉ nh·∫≠n th∆∞·ªüng.")
@app_commands.describe(code_to_redeem="M√£ code b·∫°n mu·ªën nh·∫≠p")
@global_rate_limit()
@is_user_not_in_game()
async def redeem_code_slash(interaction: discord.Interaction, code_to_redeem: str):
    await interaction.response.defer(ephemeral=True)
    user_id = interaction.user.id; user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return
    code_to_redeem = code_to_redeem.upper()
    try: code_response = supabase.table('gift_codes').select('*').eq('code', code_to_redeem).execute()
    except Exception as e: await interaction.followup.send(f'L·ªói khi ki·ªÉm tra code: {e}'); return
    if not code_response.data: await interaction.followup.send(f'M√£ `{code_to_redeem}` kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.'); return
    if code_to_redeem in user_data.get('used_codes', []): await interaction.followup.send(f'B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ `{code_to_redeem}` n√†y r·ªìi.'); return
    reward = code_response.data[0]['reward']; new_balance = update_balance(user_id, reward)
    if new_balance is None: await interaction.followup.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try: new_code_list = user_data.get('used_codes', []) + [code_to_redeem]; supabase.table('profiles').update({'used_codes': new_code_list}).eq('user_id', user_id).execute(); await interaction.followup.send(f'üéÅ {interaction.user.mention}, b·∫°n ƒë√£ nh·∫≠p th√†nh c√¥ng m√£ `{code_to_redeem}` v√† nh·∫≠n ƒë∆∞·ª£c **{reward:,}** token! S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await interaction.followup.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t code ƒë√£ d√πng: {e}')

@bot.slash_command(name="top", description="Xem b·∫£ng x·∫øp h·∫°ng nh·ªØng ng∆∞·ªùi gi√†u nh·∫•t.")
@app_commands.describe(top_n="S·ªë l∆∞·ª£ng ng∆∞·ªùi mu·ªën xem (m·∫∑c ƒë·ªãnh 10)")
@global_rate_limit()
async def leaderboard_slash(interaction: discord.Interaction, top_n: int = 10):
    await interaction.response.defer()
    if top_n <= 0: top_n = 10
    if top_n > 25: top_n = 25
    try:
        response = supabase.table('profiles').select('user_id', 'balance').order('balance', desc=True).limit(top_n).execute()
        if not response.data: await interaction.followup.send('Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng.'); return
        embed = discord.Embed(title=f"üèÜ B·∫£ng X·∫øp H·∫°ng {top_n} ƒê·∫°i Gia üèÜ", color=discord.Color.gold()); rank_count = 1
        for user_data in response.data:
             user_mention = f"<@{user_data['user_id']}>" # T·∫°o mention string
             embed.add_field(name=f"#{rank_count}: {user_mention}", value=f"**{user_data.get('balance', 0):,}** ü™ô", inline=False); rank_count += 1
        await interaction.followup.send(embed=embed)
    except Exception as e: await interaction.followup.send(f'L·ªói khi l·∫•y b·∫£ng x·∫øp h·∫°ng: {e}', ephemeral=True)

@bot.slash_command(name="chuyenxu", description="Chuy·ªÉn token cho ng∆∞·ªùi d√πng kh√°c.")
@app_commands.describe(recipient="Ng∆∞·ªùi b·∫°n mu·ªën chuy·ªÉn token ƒë·∫øn", amount="S·ªë l∆∞·ª£ng token mu·ªën chuy·ªÉn")
@global_rate_limit()
@is_user_not_in_game()
async def transfer_tokens_slash(interaction: discord.Interaction, recipient: discord.Member, amount: int):
    await interaction.response.defer()
    sender_id = interaction.user.id; recipient_id = recipient.id
    if sender_id == recipient_id: await interaction.followup.send('B·∫°n kh√¥ng th·ªÉ t·ª± chuy·ªÉn cho ch√≠nh m√¨nh!', ephemeral=True); return
    if amount <= 0: await interaction.followup.send('S·ªë ti·ªÅn chuy·ªÉn ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    sender_data = get_user_data(sender_id)
    if not sender_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu ng∆∞·ªùi g·ª≠i.", ephemeral=True); return
    if sender_data.get('balance', 0) < amount: await interaction.followup.send(f'B·∫°n kh√¥ng ƒë·ªß ti·ªÅn. B·∫°n ch·ªâ c√≥ **{sender_data.get("balance", 0):,}** ü™ô.', ephemeral=True); return
    # Th·ª±c hi·ªán chuy·ªÉn ti·ªÅn (c·∫ßn ƒë·∫£m b·∫£o c·∫£ hai update th√†nh c√¥ng - transaction l√Ω t∆∞·ªüng nh·∫•t)
    sender_new_balance = update_balance(sender_id, -amount)
    if sender_new_balance is None: await interaction.followup.send("L·ªói khi tr·ª´ ti·ªÅn ng∆∞·ªùi g·ª≠i!", ephemeral=True); return # B√°o l·ªói n·∫øu tr·ª´ ti·ªÅn th·∫•t b·∫°i
    recipient_new_balance = update_balance(recipient_id, amount)
    if recipient_new_balance is None:
        # L·ªói c·ªông ti·ªÅn ng∆∞·ªùi nh·∫≠n -> Ho√†n ti·ªÅn ng∆∞·ªùi g·ª≠i
        update_balance(sender_id, amount) # C·ªë g·∫Øng ho√†n ti·ªÅn
        await interaction.followup.send("L·ªói khi c·ªông ti·ªÅn ng∆∞·ªùi nh·∫≠n! Giao d·ªãch b·ªã h·ªßy.", ephemeral=True); return
    await interaction.followup.send(f'‚úÖ {interaction.user.mention} ƒë√£ chuy·ªÉn **{amount:,}** ü™ô cho {recipient.mention}!')

@bot.slash_command(name="profile", description="Xem h·ªì s∆° c·ªßa b·∫°n ho·∫∑c ng∆∞·ªùi kh√°c.")
@app_commands.describe(member="Ng∆∞·ªùi d√πng b·∫°n mu·ªën xem h·ªì s∆° (ƒë·ªÉ tr·ªëng n·∫øu l√† b·∫°n)")
@global_rate_limit()
async def profile_slash(interaction: discord.Interaction, member: typing.Optional[discord.Member]):
    await interaction.response.defer()
    target_user = member or interaction.user; user_data = get_user_data(target_user.id)
    if not user_data: await interaction.followup.send(f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho {target_user.mention}."); return
    balance = user_data.get('balance', 0); total_bet = user_data.get('total_bet', 0); total_won = user_data.get('total_won', 0); games_played = user_data.get('games_played', 0)
    net_profit = total_won - total_bet; streak = user_data.get('daily_streak', 0)
    embed = discord.Embed(title=f"üìä H·ªì s∆° c·ªßa {target_user.display_name}", color=target_user.color); embed.set_thumbnail(url=target_user.display_avatar.url)
    embed.add_field(name="üí∞ S·ªë d∆∞", value=f"**{balance:,}** ü™ô", inline=True); embed.add_field(name="üî• Chu·ªói Daily", value=f"{streak} ng√†y", inline=True); embed.add_field(name="üé≤ S·ªë game ƒë√£ ch∆°i", value=f"{games_played:,}", inline=True)
    embed.add_field(name="üìà T·ªïng c∆∞·ª£c", value=f"{total_bet:,} ü™ô", inline=False); embed.add_field(name="üèÜ T·ªïng l·ªùi", value=f"{total_won:,} ü™ô", inline=False)
    embed.add_field(name="üíπ L√£i/L·ªó r√≤ng", value=f"**{net_profit:,}** ü™ô", inline=False)
    await interaction.followup.send(embed=embed)


# --- L·ªÜNH ADMIN (SLASH COMMANDS) ---
admin_group = app_commands.Group(name="admin", description="C√°c l·ªánh qu·∫£n l√Ω bot", guild_only=True, default_permissions=discord.Permissions(manage_guild=True)) # Ch·ªâ ng∆∞·ªùi c√≥ quy·ªÅn Manage Server th·∫•y?

@admin_group.command(name="give", description="C·ªông/Tr·ª´ token cho ng∆∞·ªùi d√πng.")
@app_commands.checks.has_role(ADMIN_ROLE) # V·∫´n check role c·ª• th·ªÉ
@global_rate_limit()
async def admin_give_slash(interaction: discord.Interaction, member: discord.Member, amount: int):
    await interaction.response.defer(ephemeral=True)
    if amount == 0: await interaction.followup.send("S·ªë l∆∞·ª£ng ph·∫£i kh√°c 0."); return
    user_id = member.id; new_balance = update_balance(user_id, amount)
    if new_balance is None: await interaction.followup.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    action = "c·ªông" if amount > 0 else "tr·ª´"; abs_amount = abs(amount)
    await interaction.followup.send(f"‚úÖ ƒê√£ {action} **{abs_amount:,}** ü™ô cho {member.mention}. S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.")

@admin_group.command(name="set", description="ƒê·∫∑t s·ªë d∆∞ c·ªßa ng∆∞·ªùi d√πng v·ªÅ m·ªôt con s·ªë c·ª• th·ªÉ.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_set_slash(interaction: discord.Interaction, member: discord.Member, amount: int):
    await interaction.response.defer(ephemeral=True)
    if amount < 0: await interaction.followup.send("Kh√¥ng th·ªÉ set s·ªë d∆∞ √¢m."); return
    try: supabase.rpc('set_balance', {'user_id_input': member.id, 'amount_input': amount}).execute(); await interaction.followup.send(f"‚úÖ ƒê√£ set s·ªë d∆∞ c·ªßa {member.mention} th√†nh **{amount:,}** ü™ô.")
    except Exception as e: await interaction.followup.send(f"ƒê√£ x·∫£y ra l·ªói khi set balance: {e}")

@admin_group.command(name="createcode", description="T·∫°o m·ªôt giftcode m·ªõi.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_createcode_slash(interaction: discord.Interaction, code: str, reward: int):
    await interaction.response.defer(ephemeral=True)
    if reward <= 0: await interaction.followup.send("Ph·∫ßn th∆∞·ªüng ph·∫£i l·ªõn h∆°n 0."); return
    code = code.upper()
    try: supabase.table('gift_codes').insert({'code': code, 'reward': reward}).execute(); await interaction.followup.send(f"‚úÖ ƒê√£ t·∫°o giftcode `{code}` tr·ªã gi√° **{reward:,}** ü™ô.")
    except Exception as e: await interaction.followup.send(f"L·ªói! Code `{code}` c√≥ th·ªÉ ƒë√£ t·ªìn t·∫°i. ({e})")

@admin_group.command(name="deletecode", description="X√≥a m·ªôt giftcode.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_deletecode_slash(interaction: discord.Interaction, code: str):
    await interaction.response.defer(ephemeral=True)
    code = code.upper()
    try: response = supabase.table('gift_codes').delete().eq('code', code).execute()
    except Exception as e: await interaction.followup.send(f"ƒê√£ x·∫£y ra l·ªói khi x√≥a code: {e}"); return
    if response.data: await interaction.followup.send(f"‚úÖ ƒê√£ x√≥a th√†nh c√¥ng giftcode `{code}`.")
    else: await interaction.followup.send(f"L·ªói! Kh√¥ng t√¨m th·∫•y giftcode n√†o t√™n l√† `{code}`.")

@admin_group.command(name="view", description="Xem chi ti·∫øt th√¥ng tin c·ªßa ng∆∞·ªùi d√πng.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_view_slash(interaction: discord.Interaction, member: discord.Member):
    await interaction.response.defer(ephemeral=True)
    user_data = get_user_data(member.id)
    if not user_data: await interaction.followup.send("Kh√¥ng t√¨m th·∫•y user."); return
    embed = discord.Embed(title=f"üëÄ Xem th√¥ng tin: {member.display_name}", color=member.color)
    for key, value in user_data.items():
        if key == 'used_codes' and isinstance(value, list): embed.add_field(name=key, value=f"`{'`, `'.join(value)}`" if value else "Ch∆∞a d√πng code n√†o", inline=False)
        elif key == 'last_daily' and value:
             try: dt_object = datetime.fromisoformat(value).astimezone(VIETNAM_TZ); embed.add_field(name=key, value=f"{dt_object.strftime('%Y-%m-%d %H:%M:%S %Z')}", inline=False)
             except: embed.add_field(name=key, value=f"`{value}` (L·ªói format)", inline=False)
        elif key == 'last_streak_date' and value:
             try: dt_object = date.fromisoformat(value); embed.add_field(name=key, value=f"{dt_object.strftime('%Y-%m-%d')}", inline=False)
             except: embed.add_field(name=key, value=f"`{value}` (L·ªói format)", inline=False)
        elif isinstance(value, (int, float)): embed.add_field(name=key, value=f"`{value:,}`", inline=False)
        else: embed.add_field(name=key, value=f"`{value}`", inline=False)
    await interaction.followup.send(embed=embed)

@admin_group.command(name="resetdaily", description="Reset th·ªùi gian daily v√† streak cho ng∆∞·ªùi d√πng.")
@app_commands.checks.has_role(ADMIN_ROLE)
@global_rate_limit()
async def admin_resetdaily_slash(interaction: discord.Interaction, member: discord.Member):
    await interaction.response.defer(ephemeral=True)
    try: supabase.table('profiles').update({'last_daily': None, 'last_streak_date': None, 'daily_streak': 0}).eq('user_id', member.id).execute(); await interaction.followup.send(f"‚úÖ ƒê√£ reset th·ªùi gian `daily` v√† streak cho {member.mention}.")
    except Exception as e: await interaction.followup.send(f"L·ªói khi reset daily: {e}")

@admin_group.command(name="announce", description="G·ª≠i th√¥ng b√°o t·ªõi k√™nh ch·ªâ ƒë·ªãnh.")
@app_commands.checks.has_role(ADMIN_ROLE)
@app_commands.describe(channel="K√™nh mu·ªën g·ª≠i th√¥ng b√°o", message="N·ªôi dung th√¥ng b√°o")
@global_rate_limit()
async def admin_announce_slash(interaction: discord.Interaction, channel: discord.TextChannel, message: str):
    await interaction.response.defer(ephemeral=True)
    try: embed = discord.Embed(title="üì¢ Th√¥ng B√°o T·ª´ Admin üì¢", description=message, color=discord.Color.orange()); embed.set_footer(text=f"G·ª≠i b·ªüi {interaction.user.display_name}"); await channel.send(embed=embed); await interaction.followup.send("‚úÖ ƒê√£ g·ª≠i th√¥ng b√°o.")
    except Exception as e: await interaction.followup.send(f"L·ªói khi g·ª≠i th√¥ng b√°o: {e}")

bot.tree.add_command(admin_group) # ƒêƒÉng k√Ω nh√≥m l·ªánh admin


# --- GAME 24/7: T√ÄI X·ªàU (UI) ---
# (Class BetModal, TaiXiuGameView, get_bet_totals, tai_xiu_game_loop gi·ªØ nguy√™n nh∆∞ user_19/user_21)
# ... D√°n code BetModal ...
# ... D√°n code TaiXiuGameView ...
# ... D√°n code get_bet_totals ...
# ... D√°n code @tasks.loop tai_xiu_game_loop (bao g·ªìm x·ª≠ l√Ω n·ªï h≈©) ...
# ... D√°n code @tai_xiu_game_loop.before_loop ...

# (L·ªánh start/stop d√πng Slash Commands, start kh√¥ng c·∫ßn role)
@bot.slash_command(name="start_taixiu", description="B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p game T√†i X·ªâu 24/7 t·∫°i k√™nh n√†y.")
@global_rate_limit()
async def start_taixiu_slash(interaction: discord.Interaction):
    global game_channel_id
    if game_channel_id and game_channel_id != interaction.channel_id and tai_xiu_game_loop.is_running():
        await interaction.response.send_message(f"Game T√†i X·ªâu ƒë√£ ch·∫°y ·ªü k√™nh <#{game_channel_id}> r·ªìi!", ephemeral=True)
        return
    game_channel_id = interaction.channel_id
    if not tai_xiu_game_loop.is_running():
        tai_xiu_game_loop.start()
        await interaction.response.send_message(f"‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu Game T√†i X·ªâu 24/7 t·∫°i k√™nh <#{game_channel_id}>.")
    else:
        await interaction.response.send_message(f"Game ƒë√£ ch·∫°y t·∫°i k√™nh <#{game_channel_id}> r·ªìi.", ephemeral=True)

@bot.slash_command(name="stop_taixiu", description="(ADMIN) D·ª´ng v√≤ng l·∫∑p game T√†i X·ªâu.")
@app_commands.checks.has_role(ADMIN_ROLE) # V·∫´n c·∫ßn admin ƒë·ªÉ d·ª´ng
@global_rate_limit()
async def stop_taixiu_slash(interaction: discord.Interaction):
    global game_channel_id
    if tai_xiu_game_loop.is_running():
        tai_xiu_game_loop.stop()
        await interaction.response.send_message("‚úÖ ƒê√£ d·ª´ng Game T√†i X·ªâu.")
        await asyncio.sleep(1) # ƒê·ª£i loop th·ª±c s·ª± d·ª´ng
        game_channel_id = None
        current_bets = {} # X√≥a c∆∞·ª£c c√≤n l·∫°i
        if game_message: # X√≥a tin nh·∫Øn game c≈© n·∫øu c√≥
            try: await game_message.delete()
            except: pass
            game_message = None
    else:
        await interaction.response.send_message("Game ch∆∞a ch·∫°y.", ephemeral=True)


# --- GAME THEO L·ªÜNH (SLASH COMMANDS, C√ì HI·ªÜU ·ª®NG V√Ä KH√ìA) ---
# (Chuy·ªÉn ƒë·ªïi !slots, !hilo, !tungxu, !xucxac, !baucua, !duangua, !quay, !baccarat sang Slash)
# V√≠ d·ª• cho slots:
@bot.slash_command(name="slots", description="Ch∆°i m√°y x√®ng.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn b·∫°n mu·ªën c∆∞·ª£c")
@global_rate_limit()
@is_user_not_in_game()
async def slots_slash(interaction: discord.Interaction, bet_amount: int):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer() # Quan tr·ªçng: b√°o Discord ch·ªù
    try:
        final_results = random.choices(SLOT_WHEEL, weights=SLOT_WEIGHTS, k=3)
        embed = discord.Embed(title="üé∞ M√°y X√®ng üé∞", description="| - | - | - |", color=discord.Color.blue())
        embed.set_footer(text=f"{interaction.user.display_name} ƒë√£ c∆∞·ª£c {bet_amount:,} ü™ô")
        slot_message = await interaction.followup.send(embed=embed, wait=True) # D√πng followup

        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | - | - |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | {final_results[1]} | - |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | {final_results[1]} | {final_results[2]} |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")

        winnings = 0; jackpot_win = 0; is_jackpot = (final_results[0] == final_results[1] == final_results[2] == '7Ô∏è‚É£')
        if is_jackpot:
            jackpot_pool = get_jackpot_pool('slots'); winnings = jackpot_pool; jackpot_win = winnings
            embed.description += f"\n\n**üí•üí•üí• JACKPOT TI·∫æN TRI·ªÇN!!! üí•üí•üí•**"; update_jackpot_pool('slots', -jackpot_pool); update_jackpot_pool('slots', 1000) # Reset v·ªÅ 1000
        elif final_results[0] == final_results[1] == final_results[2]:
            payout = SLOT_PAYOUTS[final_results[0]]; winnings = bet_amount * payout
            embed.description += f"\n\n**JACKPOT!** B·∫°n tr√∫ng 3x {final_results[0]} (1 ƒÉn {payout})!"
        elif final_results[0] == final_results[1] or final_results[1] == final_results[2]:
            matching_symbol = final_results[1]; winnings = bet_amount * 1 # Ch·ªâ tr·∫£ 1:1 cho 2x
            embed.description += f"\n\nB·∫°n tr√∫ng 2x {matching_symbol} (1 ƒÉn 1)!"

        jackpot_contrib = int(bet_amount * 0.01) if not is_jackpot and bet_amount > 0 else 0 # Ch·ªâ contrib n·∫øu c∆∞·ª£c > 0
        if jackpot_contrib > 0: update_jackpot_pool('slots', jackpot_contrib)
        net_gain = winnings if is_jackpot else (winnings - jackpot_contrib if winnings > 0 else -(bet_amount - jackpot_contrib)) # T√≠nh net gain/loss ch√≠nh x√°c h∆°n
        new_balance = update_balance(user_id, net_gain)
        update_profile_stats(user_id, bet_amount, net_gain)

        if winnings > 0: embed.description += f"\nüéâ B·∫°n th·∫Øng **{winnings:,}** ü™ô!\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description += f"\n\nüò¢ Ch√∫c may m·∫Øn l·∫ßn sau.\nB·∫°n m·∫•t **{bet_amount:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        current_jackpot = get_jackpot_pool('slots'); embed.add_field(name="üí∞ Jackpot Slots Hi·ªán T·∫°i", value=f"**{current_jackpot:,}** ü™ô", inline=False)

        try: await slot_message.edit(embed=embed)
        except discord.NotFound: await interaction.followup.send(embed=embed) # G·ª≠i l·∫°i n·∫øu b·ªã x√≥a

    except asyncio.CancelledError: await interaction.followup.send("Tr√≤ ch∆°i b·ªã h·ªßy do tin nh·∫Øn b·ªã x√≥a.", ephemeral=True)
    except Exception as e: print(f"L·ªói /slots: {e}"); await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ch∆°i Slots.", ephemeral=True)
    finally: bot.users_in_animation.discard(user_id)

# ... (T∆∞∆°ng t·ª± chuy·ªÉn ƒë·ªïi /hilo, /tungxu, /xucxac, /baucua, /duangua, /quay, /baccarat) ...
@bot.slash_command(name="hilo", description="ƒêo√°n l√° b√†i ti·∫øp theo cao hay th·∫•p h∆°n.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", choice="ƒêo√°n 'cao' hay 'th·∫•p'")
@app_commands.choices(choice=[
    app_commands.Choice(name="Cao", value="cao"),
    app_commands.Choice(name="Th·∫•p", value="th·∫•p")
])
@global_rate_limit()
@is_user_not_in_game()
async def hilo_slash(interaction: discord.Interaction, bet_amount: int, choice: str):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer() # B√°o Discord ch·ªù
    try:
        # R√∫t l√° 1
        rank1 = random.choice(list(CARD_RANKS_HILO.keys())); suit1 = random.choice(CARD_SUITS); val1 = CARD_RANKS_HILO[rank1]; card1_str = f"**{rank1}{suit1}** (Gi√° tr·ªã: {val1})"

        embed = discord.Embed(title="‚¨ÜÔ∏è Cao hay Th·∫•p ‚¨áÔ∏è", color=discord.Color.blue())
        embed.add_field(name="L√° b√†i ƒë·∫ßu ti√™n", value=card1_str, inline=False)
        embed.add_field(name="B·∫°n c∆∞·ª£c", value=f"**{bet_amount:,}** ü™ô v√†o **{choice.upper()}**", inline=False)
        embed.add_field(name="L√° b√†i ti·∫øp theo", value="ƒêang r√∫t b√†i...", inline=False)
        msg = await interaction.followup.send(embed=embed, wait=True)
        await asyncio.sleep(3)

        # R√∫t l√° 2
        rank2 = random.choice(list(CARD_RANKS_HILO.keys())); suit2 = random.choice(CARD_SUITS); val2 = CARD_RANKS_HILO[rank2]; card2_str = f"**{rank2}{suit2}** (Gi√° tr·ªã: {val2})"
        embed.set_field_at(2, name="L√° b√†i ti·∫øp theo", value=card2_str, inline=False)

        is_win = False
        result_desc = ""
        if val2 > val1:
            result_desc = f"{val2} **L·ªöN H∆†N** {val1}"
            if choice == 'cao': is_win = True
        elif val2 < val1:
            result_desc = f"{val2} **NH·ªé H∆†N** {val1}"
            if choice == 'th·∫•p': is_win = True
        else: # val1 == val2
            result_desc = "B·∫±ng nhau! Nh√† c√°i th·∫Øng."
            is_win = False

        embed.add_field(name="K·∫øt qu·∫£", value=result_desc, inline=False)

        payout = bet_amount if is_win else -bet_amount
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        if is_win: embed.description = f"üéâ **B·∫°n ƒë√£ th·∫Øng!**\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description = f"üò¢ **B·∫°n ƒë√£ thua!**\nB·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()

        await msg.edit(embed=embed)
    except Exception as e:
        print(f"L·ªói /hilo: {e}")
        await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ch∆°i Cao/Th·∫•p.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

@bot.slash_command(name="tungxu", description="C∆∞·ª£c 50/50 s·∫•p hay ng·ª≠a.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", choice="ƒêo√°n 's·∫•p' hay 'ng·ª≠a'")
@app_commands.choices(choice=[
    app_commands.Choice(name="S·∫•p", value="s·∫•p"),
    app_commands.Choice(name="Ng·ª≠a", value="ng·ª≠a")
])
@global_rate_limit()
@is_user_not_in_game()
async def coinflip_slash(interaction: discord.Interaction, bet_amount: int, choice: str):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer()
    try:
        embed = discord.Embed(title="ü™ô ƒêang tung ƒë·ªìng xu...", description="ƒê·ªìng xu ƒëang xoay tr√™n kh√¥ng...", color=discord.Color.blue())
        msg = await interaction.followup.send(embed=embed, wait=True)
        await asyncio.sleep(2.5)

        result = random.choice(['s·∫•p', 'ng·ª≠a'])
        # Chu·∫©n h√≥a choice ƒë·∫ßu v√†o (n·∫øu ng∆∞·ªùi d√πng g√µ sap/ngua)
        normalized_choice = 's·∫•p' if choice in ['s·∫•p', 'sap'] else 'ng·ª≠a'
        is_win = (normalized_choice == result)

        payout = bet_amount if is_win else -bet_amount
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        embed.title = f"Tung ƒë·ªìng xu ü™ô... K·∫øt qu·∫£ l√† **{result.upper()}**!"
        if is_win: embed.description = f"üéâ B·∫°n ƒëo√°n ƒë√∫ng! B·∫°n th·∫Øng **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description = f"üò¢ B·∫°n ƒëo√°n sai! B·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except Exception as e:
        print(f"L·ªói /tungxu: {e}")
        await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi tung xu.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

@bot.slash_command(name="xucxac", description="ƒêo√°n k·∫øt qu·∫£ 1 vi√™n x√∫c x·∫Øc (1-6), th·∫Øng 1 ƒÉn 5.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", guess="S·ªë b·∫°n ƒëo√°n (1 ƒë·∫øn 6)")
@global_rate_limit()
@is_user_not_in_game()
async def dice_roll_slash(interaction: discord.Interaction, bet_amount: int, guess: app_commands.Range[int, 1, 6]): # D√πng Range ƒë·ªÉ gi·ªõi h·∫°n
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer()
    try:
        embed = discord.Embed(title="üé≤ ƒêang gieo x√∫c x·∫Øc...", description="X√∫c x·∫Øc ƒëang lƒÉn...", color=discord.Color.dark_purple())
        msg = await interaction.followup.send(embed=embed, wait=True)
        await asyncio.sleep(2.5)

        result = random.randint(1, 6)
        is_win = (guess == result)
        winnings = bet_amount * 5 if is_win else 0
        payout = winnings if is_win else -bet_amount
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        embed.title = f"Gieo x√∫c x·∫Øc üé≤... K·∫øt qu·∫£ l√† **{result}**!"
        if is_win: embed.description = f"üéâ Ch√≠nh x√°c! B·∫°n th·∫Øng **{winnings:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description = f"üò¢ B·∫°n ƒëo√°n sai! B·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except Exception as e:
        print(f"L·ªói /xucxac: {e}")
        await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi gieo x√∫c x·∫Øc.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

@bot.slash_command(name="baucua", description="C∆∞·ª£c B·∫ßu Cua T√¥m C√°.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", choice="Linh v·∫≠t b·∫°n mu·ªën c∆∞·ª£c")
@app_commands.choices(choice=[ # T·∫°o l·ª±a ch·ªçn s·∫µn cho ng∆∞·ªùi d√πng
    app_commands.Choice(name="B·∫ßu üçê", value="b·∫ßu"),
    app_commands.Choice(name="Cua ü¶Ä", value="cua"),
    app_commands.Choice(name="T√¥m ü¶ê", value="t√¥m"),
    app_commands.Choice(name="C√° üêü", value="c√°"),
    app_commands.Choice(name="G√† üêì", value="g√†"),
    app_commands.Choice(name="Nai ü¶å", value="nai"),
])
@global_rate_limit()
@is_user_not_in_game()
async def bau_cua_slash(interaction: discord.Interaction, bet_amount: int, choice: str):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    user_choice_full = BAU_CUA_FACES.get(choice.lower().strip()) # L·∫•y t√™n ƒë·∫ßy ƒë·ªß + emoji
    if not user_choice_full: await interaction.response.send_message('L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá!', ephemeral=True); return # L·ªói n√†y kh√¥ng n√™n x·∫£y ra v·ªõi choices

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer()
    try:
        final_results = random.choices(BAU_CUA_LIST, k=3)
        embed = discord.Embed(title="ü¶Ä ƒêang l·∫Øc B·∫ßu Cua...", description="| ‚ùî | ‚ùî | ‚ùî |", color=discord.Color.dark_orange())
        embed.set_footer(text=f"{interaction.user.display_name} c∆∞·ª£c {bet_amount:,} ü™ô v√†o {user_choice_full}")
        msg = await interaction.followup.send(embed=embed, wait=True)
        current_display = ['‚ùî'] * 3
        for i in range(5): # Hi·ªáu ·ª©ng kh√≥a
            if i < 2: current_display[0] = random.choice(BAU_CUA_LIST)
            else: current_display[0] = final_results[0]
            if i < 3: current_display[1] = random.choice(BAU_CUA_LIST)
            else: current_display[1] = final_results[1]
            if i < 4: current_display[2] = random.choice(BAU_CUA_LIST)
            else: current_display[2] = final_results[2]
            embed.description = f"| **{current_display[0]}** | **{current_display[1]}** | **{current_display[2]}** |"
            try: await msg.edit(embed=embed)
            except discord.NotFound: raise asyncio.CancelledError("Message deleted")
            await asyncio.sleep(0.7)

        hits = final_results.count(user_choice_full)
        is_win = (hits > 0)
        winnings = bet_amount * hits if is_win else 0
        payout = winnings if is_win else -bet_amount
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        embed.title = "ü¶Ä L·∫Øc B·∫ßu Cua üé≤"
        if is_win: embed.description += f"\n\nüéâ **B·∫°n ƒë√£ th·∫Øng!** Tr√∫ng {hits} l·∫ßn.\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{winnings:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description += f"\n\nüò¢ **B·∫°n ƒë√£ thua!** B·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except asyncio.CancelledError: await interaction.followup.send("Tr√≤ ch∆°i b·ªã h·ªßy do tin nh·∫Øn b·ªã x√≥a.", ephemeral=True)
    except Exception as e:
        print(f"L·ªói /baucua: {e}")
        await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ch∆°i B·∫ßu Cua.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

# Helper function for horse race track display
def get_race_track(positions):
    track = ""
    for i in range(NUM_HORSES):
        pos_clamped = min(positions[i], RACE_LENGTH)
        # Display trophy only if exactly at finish line or beyond
        finish_char = 'üèÜ' if positions[i] >= RACE_LENGTH else 'üèÅ'
        track += f"üêé {i+1}: {'‚îÄ' * pos_clamped}{finish_char}\n" # Use a different dash
    return track

@bot.slash_command(name="duangua", description="C∆∞·ª£c ƒëua ng·ª±a (1-6), th·∫Øng 1 ƒÉn 4.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", horse_number="Ng·ª±a b·∫°n ch·ªçn (1 ƒë·∫øn 6)")
@global_rate_limit()
@is_user_not_in_game()
async def dua_ngua_slash(interaction: discord.Interaction, bet_amount: int, horse_number: app_commands.Range[int, 1, NUM_HORSES]):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer()
    try:
        positions = [0] * NUM_HORSES
        embed = discord.Embed(title="üêé Cu·ªôc ƒêua B·∫Øt ƒê·∫ßu! üêé", description=get_race_track(positions), color=discord.Color.blue())
        embed.set_footer(text=f"{interaction.user.display_name} c∆∞·ª£c {bet_amount:,} ü™ô v√†o ng·ª±a s·ªë {horse_number}.")
        race_msg = await interaction.followup.send(embed=embed, wait=True)

        winner = None
        while winner is None:
            await asyncio.sleep(2)
            # Determine winner(s) in this step
            potential_winners = []
            for i in range(NUM_HORSES):
                if positions[i] < RACE_LENGTH: # Only move horses not finished
                    positions[i] += random.randint(1, 3)
                    if positions[i] >= RACE_LENGTH:
                        potential_winners.append(i + 1)

            # Check if there's a winner or a tie
            if potential_winners:
                 # Simple tie-breaking: lowest number wins if tied in the same step
                 winner = min(potential_winners)

            # Update display
            embed.description = get_race_track(positions)
            try: await race_msg.edit(embed=embed)
            except discord.NotFound: raise asyncio.CancelledError("Message deleted")
            # Loop breaks naturally if winner is found

        is_win = (winner == horse_number)
        winnings = bet_amount * 4 if is_win else 0
        payout = winnings if is_win else -bet_amount
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        result_title = f"üêé Ng·ª±a s·ªë {winner} ƒë√£ chi·∫øn th·∫Øng! üèÜ"
        result_description = get_race_track(positions) # Final track display
        if is_win:
            result_description += f"\n\nüéâ **B·∫°n ƒë√£ th·∫Øng!** Ng·ª±a s·ªë {horse_number} ƒë√£ v·ªÅ nh·∫•t!\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{winnings:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else:
            result_description += f"\n\nüò¢ **B·∫°n ƒë√£ thua!** Ng·ª±a c·ªßa b·∫°n (s·ªë {horse_number}) ƒë√£ kh√¥ng th·∫Øng.\nB·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        embed.title = result_title; embed.description = result_description
        try: await race_msg.edit(embed=embed)
        except discord.NotFound: await interaction.followup.send(embed=embed) # Send new if deleted
    except asyncio.CancelledError: await interaction.followup.send("Tr√≤ ch∆°i b·ªã h·ªßy do tin nh·∫Øn b·ªã x√≥a.", ephemeral=True)
    except Exception as e:
        print(f"L·ªói /duangua: {e}")
        await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ƒëua ng·ª±a.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

# Helper function to parse complex Roulette bets
def parse_roulette_bet(bet_type_str):
    bet_type_str = bet_type_str.lower().strip()
    numbers_involved = []
    payout_category = None

    # Single number
    if bet_type_str.isdigit() and 0 <= int(bet_type_str) <= 36:
        numbers_involved.append(int(bet_type_str))
        payout_category = 'single'
    # Colors, Even/Odd, Halves
    elif bet_type_str in ['ƒë·ªè', 'red']: payout_category = 'color'; numbers_involved = RED_NUMBERS
    elif bet_type_str in ['ƒëen', 'black']: payout_category = 'color'; numbers_involved = BLACK_NUMBERS
    elif bet_type_str in ['l·∫ª', 'odd']: payout_category = 'evenodd'; numbers_involved = [n for n in range(1, 37) if n % 2 != 0]
    elif bet_type_str in ['ch·∫µn', 'even']: payout_category = 'evenodd'; numbers_involved = [n for n in range(1, 37) if n % 2 == 0]
    elif bet_type_str in ['n·ª≠a1', '1-18']: payout_category = 'half'; numbers_involved = list(range(1, 19))
    elif bet_type_str in ['n·ª≠a2', '19-36']: payout_category = 'half'; numbers_involved = list(range(19, 37))
    # Dozens
    elif bet_type_str in ['t√°1', '1-12', 'dozen1']: payout_category = 'dozen'; numbers_involved = list(range(1, 13))
    elif bet_type_str in ['t√°2', '13-24', 'dozen2']: payout_category = 'dozen'; numbers_involved = list(range(13, 25))
    elif bet_type_str in ['t√°3', '25-36', 'dozen3']: payout_category = 'dozen'; numbers_involved = list(range(25, 37))
    # Columns (Example: col1 includes 1, 4, 7,... 34)
    elif bet_type_str in ['c·ªôt1', 'col1']: payout_category = 'column'; numbers_involved = [n for n in range(1, 37) if n % 3 == 1]
    elif bet_type_str in ['c·ªôt2', 'col2']: payout_category = 'column'; numbers_involved = [n for n in range(1, 37) if n % 3 == 2]
    elif bet_type_str in ['c·ªôt3', 'col3']: payout_category = 'column'; numbers_involved = [n for n in range(1, 37) if n % 3 == 0]
    # Complex bets (Split, Street, Corner, Six Line) using regex
    else:
        # Split (e.g., split-1-2, split-17-20)
        split_match = re.match(r"split-(\d{1,2})-(\d{1,2})", bet_type_str)
        if split_match:
            n1, n2 = int(split_match.group(1)), int(split_match.group(2))
            # Basic validation (add more robust checks if needed, e.g., adjacency)
            if 1 <= n1 <= 36 and 1 <= n2 <= 36 and n1 != n2:
                numbers_involved = [n1, n2]; payout_category = 'split'
        # Street (e.g., street-1-2-3, street-34-35-36)
        street_match = re.match(r"street-(\d{1,2})-(\d{1,2})-(\d{1,2})", bet_type_str)
        if street_match:
            n1, n2, n3 = int(street_match.group(1)), int(street_match.group(2)), int(street_match.group(3))
            if 1 <= n1 <= 36 and 1 <= n2 <= 36 and 1 <= n3 <= 36 and n1 != n2 != n3 != n1:
                 numbers_involved = [n1, n2, n3]; payout_category = 'street'
        # Corner (e.g., corner-1-2-4-5)
        corner_match = re.match(r"corner-(\d{1,2})-(\d{1,2})-(\d{1,2})-(\d{1,2})", bet_type_str)
        if corner_match:
             n1, n2, n3, n4 = map(int, corner_match.groups())
             if all(1 <= n <= 36 for n in [n1, n2, n3, n4]) and len(set([n1, n2, n3, n4])) == 4:
                 numbers_involved = [n1, n2, n3, n4]; payout_category = 'corner'
        # Six Line (e.g., sixline-1-6)
        sixline_match = re.match(r"sixline-(\d{1,2})-(\d{1,2})", bet_type_str)
        if sixline_match:
             start, end = int(sixline_match.group(1)), int(sixline_match.group(2))
             # Basic validation: ensure it's a valid range of 6
             if 1 <= start <= 31 and end == start + 5:
                  numbers_involved = list(range(start, end + 1)); payout_category = 'sixline'

    if not payout_category:
        raise ValueError(f"Invalid Roulette bet type: {bet_type_str}")

    return {'category': payout_category, 'numbers': numbers_involved}


@bot.slash_command(name="quay", description="Ch∆°i Roulette.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", bet_type="Lo·∫°i c∆∞·ª£c (s·ªë, m√†u, t√°, c·ªôt, split-x-y, etc.)")
@global_rate_limit()
@is_user_not_in_game()
async def roulette_slash(interaction: discord.Interaction, bet_amount: int, bet_type: str):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    try:
        parsed_bet = parse_roulette_bet(bet_type)
    except ValueError as e:
        await interaction.response.send_message(str(e), ephemeral=True)
        return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer()
    try:
        embed = discord.Embed(title="üé∞ V√≤ng quay Roulette üé∞", description="B√≥ng ƒëang quay... üîÑ", color=discord.Color.dark_red())
        embed.set_footer(text=f"{interaction.user.display_name} c∆∞·ª£c {bet_amount:,} ü™ô v√†o {bet_type}")
        msg = await interaction.followup.send(embed=embed, wait=True)

        spin_result = random.randint(0, 36)
        spin_color = 'xanh l√° üü©' if spin_result == 0 else ('ƒë·ªè üü•' if spin_result in RED_NUMBERS else 'ƒëen ‚¨õ')
        await asyncio.sleep(4)

        is_win = (spin_result != 0 and spin_result in parsed_bet['numbers']) or \
                 (spin_result == 0 and 0 in parsed_bet['numbers']) # Check win condition

        winnings = 0
        payout_rate = 0
        if is_win:
            payout_rate = ROULETTE_PAYOUTS[parsed_bet['category']]
            winnings = bet_amount * payout_rate

        payout = winnings if is_win else -bet_amount
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        result_message = f"**B√≥ng d·ª´ng t·∫°i s·ªë: {spin_result} ({spin_color})**\n\n"
        result_message += f"{interaction.user.mention} ƒë√£ c∆∞·ª£c **{bet_amount:,}** ü™ô v√†o **{bet_type}**.\n"

        if is_win:
            result_message += f"üéâ **B·∫°n ƒë√£ th·∫Øng!** (1 ƒÉn {payout_rate})\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{winnings:,}** token.\n"; embed.color = discord.Color.green()
        else:
            result_message += f"üò¢ **B·∫°n ƒë√£ thua!**\nB·∫°n m·∫•t **{bet_amount:,}** token.\n"; embed.color = discord.Color.red()
        result_message += f"S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
        embed.description = result_message
        await msg.edit(embed=embed)

    except Exception as e:
        print(f"L·ªói /quay: {e}")
        # Dont send error if due to invalid bet handled above
        if "Invalid Roulette bet type" not in str(e):
             await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ch∆°i Roulette.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

# Helper to create Baccarat deck (A=1, JQK=0)
def create_baccarat_deck():
    deck = []
    for suit in CARD_SUITS:
        for rank, value in CARD_RANKS_BACCARAT.items():
            deck.append({'rank': rank, 'suit': suit, 'value': value})
    random.shuffle(deck)
    return deck

# Helper to calculate Baccarat score (unit digit)
def calculate_baccarat_score(hand):
    return sum(card['value'] for card in hand) % 10

@bot.slash_command(name="baccarat", description="Ch∆°i Baccarat. C∆∞·ª£c Player, Banker, ho·∫∑c Tie.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c", choice="C·ª≠a b·∫°n mu·ªën c∆∞·ª£c")
@app_commands.choices(choice=[
    app_commands.Choice(name="Player", value="player"),
    app_commands.Choice(name="Banker", value="banker"),
    app_commands.Choice(name="Tie (H√≤a)", value="tie")
])
@global_rate_limit()
@is_user_not_in_game()
async def baccarat_slash(interaction: discord.Interaction, bet_amount: int, choice: str):
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)

    if bet_amount <= 0: await interaction.response.send_message('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.response.send_message(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    bot.users_in_animation.add(user_id)
    await interaction.response.defer()
    try:
        embed = discord.Embed(title="üÉè Baccarat üÉè", description="ƒêang chia b√†i...", color=discord.Color.dark_green())
        embed.set_footer(text=f"{interaction.user.display_name} c∆∞·ª£c {bet_amount:,} ü™ô v√†o {choice.upper()}")
        msg = await interaction.followup.send(embed=embed, wait=True)
        await asyncio.sleep(3)

        deck = create_baccarat_deck()
        player_hand = [deck.pop(), deck.pop()]
        banker_hand = [deck.pop(), deck.pop()]
        player_score = calculate_baccarat_score(player_hand)
        banker_score = calculate_baccarat_score(banker_hand)

        player_draw = False
        player_third_card_value = -1 # Gi√° tr·ªã l√° th·ª© 3 c·ªßa player (n·∫øu r√∫t)

        # Ki·ªÉm tra Natural win
        natural_win = False
        if player_score >= 8 or banker_score >= 8:
             natural_win = True
        else:
            # Lu·∫≠t r√∫t l√° th·ª© 3
            if player_score <= 5: # Player draws
                player_third_card = deck.pop()
                player_hand.append(player_third_card)
                player_score = calculate_baccarat_score(player_hand)
                player_draw = True
                player_third_card_value = player_third_card['value']

            banker_draws = False
            if not player_draw: # Player stands
                if banker_score <= 5: banker_draws = True
            else: # Player draws
                if banker_score <= 2: banker_draws = True
                elif banker_score == 3 and player_third_card_value != 8: banker_draws = True
                elif banker_score == 4 and player_third_card_value in [2, 3, 4, 5, 6, 7]: banker_draws = True
                elif banker_score == 5 and player_third_card_value in [4, 5, 6, 7]: banker_draws = True
                elif banker_score == 6 and player_third_card_value in [6, 7]: banker_draws = True

            if banker_draws:
                banker_hand.append(deck.pop())
                banker_score = calculate_baccarat_score(banker_hand)

        # X√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng
        winner = "tie"
        if player_score > banker_score: winner = "player"
        elif banker_score > player_score: winner = "banker"

        winnings = 0; payout = 0
        if winner == choice:
            if winner == 'player': winnings = bet_amount * 1; payout = winnings
            elif winner == 'banker': winnings = int(bet_amount * 0.95); payout = winnings
            elif winner == 'tie': winnings = bet_amount * 8; payout = winnings
        else:
            payout = -bet_amount # Thua

        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)

        embed.title = f"üÉè Baccarat - {winner.upper()} Th·∫Øng! üÉè"
        embed.add_field(name=f"Player ({player_score})", value=hand_to_string(player_hand), inline=True)
        embed.add_field(name=f"Banker ({banker_score})", value=hand_to_string(banker_hand), inline=True)
        if payout >= 0: # Bao g·ªìm c·∫£ h√≤a (payout=0)
            embed.description = f"üéâ B·∫°n c∆∞·ª£c {choice.upper()} v√† ƒë√£ {'th·∫Øng' if payout > 0 else 'h√≤a'}!\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{winnings:,}** ü™ô!\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else:
            embed.description = f"üò¢ B·∫°n c∆∞·ª£c {choice.upper()} v√† ƒë√£ thua!\nB·∫°n m·∫•t **{bet_amount:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()

        await msg.edit(embed=embed)
    except Exception as e:
        print(f"L·ªói /baccarat: {e}")
        await interaction.followup.send("ƒê√£ x·∫£y ra l·ªói khi ch∆°i Baccarat.", ephemeral=True)
    finally:
        bot.users_in_animation.discard(user_id)

lottery_group = app_commands.Group(name="lottery", description="L·ªánh li√™n quan ƒë·∫øn x·ªï s·ªë")

@lottery_group.command(name="buy", description="Mua v√© s·ªë (6 s·ªë t·ª´ 1 ƒë·∫øn 45).")
@app_commands.describe(n1="S·ªë 1", n2="S·ªë 2", n3="S·ªë 3", n4="S·ªë 4", n5="S·ªë 5", n6="S·ªë 6")
@global_rate_limit()
@is_user_not_in_game()
async def lottery_buy_slash(interaction: discord.Interaction,
                             n1: app_commands.Range[int, 1, 45], n2: app_commands.Range[int, 1, 45],
                             n3: app_commands.Range[int, 1, 45], n4: app_commands.Range[int, 1, 45],
                             n5: app_commands.Range[int, 1, 45], n6: app_commands.Range[int, 1, 45]):
    await interaction.response.defer(ephemeral=True)
    user_id = interaction.user.id
    user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return
    balance = user_data.get('balance', 0)

    numbers = sorted(list(set([n1, n2, n3, n4, n5, n6]))) # S·∫Øp x·∫øp v√† lo·∫°i tr√πng

    if len(numbers) != 6: await interaction.followup.send("Ph·∫£i ch·ªçn ƒë√∫ng 6 s·ªë kh√°c nhau."); return
    # Range ƒë√£ ki·ªÉm tra 1-45

    if balance < LOTTERY_TICKET_PRICE: await interaction.followup.send(f"B·∫°n kh√¥ng ƒë·ªß ti·ªÅn mua v√©! C·∫ßn {LOTTERY_TICKET_PRICE} ü™ô."); return

    new_balance = update_balance(user_id, -LOTTERY_TICKET_PRICE)
    if new_balance is None: await interaction.followup.send("L·ªói khi tr·ª´ ti·ªÅn!"); return
    update_profile_stats(user_id, LOTTERY_TICKET_PRICE, -LOTTERY_TICKET_PRICE)

    today = datetime.now(VIETNAM_TZ).date()
    try:
        supabase.table('lottery_tickets').insert({'user_id': user_id, 'numbers': numbers, 'draw_date': str(today)}).execute()
        await interaction.followup.send(f"‚úÖ B·∫°n ƒë√£ mua th√†nh c√¥ng v√© s·ªë cho ng√†y {today.strftime('%d/%m/%Y')} v·ªõi c√°c s·ªë: `{' '.join(map(str, numbers))}`. S·ªë d∆∞: {new_balance:,} ü™ô.")
    except Exception as e:
        await interaction.followup.send(f"L·ªói khi l∆∞u v√© s·ªë: {e}")
        # C·ªë g·∫Øng ho√†n ti·ªÅn
        update_balance(user_id, LOTTERY_TICKET_PRICE)
        update_profile_stats(user_id, 0, LOTTERY_TICKET_PRICE)


@lottery_group.command(name="result", description="Xem k·∫øt qu·∫£ x·ªï s·ªë g·∫ßn nh·∫•t.")
@global_rate_limit()
async def lottery_result_slash(interaction: discord.Interaction):
    await interaction.response.defer()
    today_vn = datetime.now(VIETNAM_TZ).date()
    try:
        result = supabase.table('lottery_draws').select('*').lte('draw_date', str(today_vn)).order('draw_date', desc=True).limit(1).execute().data
        if not result: await interaction.followup.send("Ch∆∞a c√≥ k·∫øt qu·∫£ x·ªï s·ªë."); return

        draw = result[0]; draw_date = date.fromisoformat(draw['draw_date']); winning_numbers = draw['winning_numbers']; jackpot = draw['jackpot_amount']; winners_data = draw['winners'] or []

        embed = discord.Embed(title=f"üèÜ K·∫øt qu·∫£ X·ªï s·ªë ng√†y {draw_date.strftime('%d/%m/%Y')} üèÜ", color=discord.Color.gold())
        embed.add_field(name="üî¢ D√£y s·ªë tr√∫ng th∆∞·ªüng", value=f"`{' '.join(map(str, winning_numbers))}`" if winning_numbers else "Ch∆∞a c√≥", inline=False)
        embed.add_field(name="üí∞ Gi·∫£i Jackpot k·ª≥ n√†y", value=f"**{jackpot:,}** ü™ô", inline=False)

        winners_text = ""
        # S·∫Øp x·∫øp ng∆∞·ªùi th·∫Øng theo gi·∫£i
        winners_data.sort(key=lambda w: int(w.get('matched', 0)), reverse=True)
        for winner in winners_data:
            user = bot.get_user(winner['user_id']) # D√πng get_user (nhanh h∆°n fetch n·∫øu user trong cache)
            username = user.display_name if user else f"User ID {winner['user_id']}"
            winners_text += f"- {username}: Tr√∫ng gi·∫£i {winner.get('prize_tier','N/A')} ({winner.get('matched', '?')} s·ªë) - **{winner.get('amount', 0):,}** ü™ô\n"
        if not winners_text: winners_text = "Kh√¥ng c√≥ ai tr√∫ng th∆∞·ªüng k·ª≥ n√†y."
        embed.add_field(name="üéâ Ng∆∞·ªùi tr√∫ng th∆∞·ªüng", value=winners_text[:1020], inline=False) # Gi·ªõi h·∫°n 1024 k√Ω t·ª±

        await interaction.followup.send(embed=embed)
    except Exception as e: await interaction.followup.send(f"L·ªói khi xem k·∫øt qu·∫£: {e}", ephemeral=True)

bot.tree.add_command(lottery_group)

# Task ch·∫°y x·ªï s·ªë h√†ng ng√†y
@tasks.loop(time=LOTTERY_DRAW_TIME)
async def lottery_draw_task():
    today = datetime.now(VIETNAM_TZ).date()
    print(f"[{datetime.now(VIETNAM_TZ)}] B·∫Øt ƒë·∫ßu quay s·ªë cho ng√†y {today}...")
    try:
        tickets_response = supabase.table('lottery_tickets').select('*').eq('draw_date', str(today)).execute()
        tickets = tickets_response.data
        if not tickets:
            print("Kh√¥ng c√≥ v√© n√†o ƒë∆∞·ª£c mua h√¥m nay. B·ªè qua quay s·ªë.")
            try: supabase.table('lottery_draws').insert({'draw_date': str(today), 'winning_numbers': [], 'jackpot_amount': 0, 'winners': []}).execute()
            except Exception as insert_e: print(f"L·ªói khi insert draw r·ªóng: {insert_e}")
            return

        winning_numbers = sorted(random.sample(range(1, 46), 6))
        total_revenue = len(tickets) * LOTTERY_TICKET_PRICE
        current_jackpot = int(total_revenue * 0.5) + 10000 # V√≠ d·ª• jackpot

        winners = []; prize_tiers = {6: 1.0, 5: 0.15, 4: 0.05, 3: 0.01}; remaining_jackpot = current_jackpot
        for match_count in sorted(prize_tiers.keys(), reverse=True):
            tier_winners = []
            for ticket in tickets:
                user_numbers = set(ticket['numbers'])
                matched = len(user_numbers.intersection(winning_numbers))
                if matched == match_count: tier_winners.append({'user_id': ticket['user_id'], 'numbers': ticket['numbers']})

            if tier_winners:
                prize_pool_tier = int(current_jackpot * prize_tiers[match_count]); prize_pool_tier = min(prize_pool_tier, remaining_jackpot)
                if prize_pool_tier > 0:
                    amount_per_winner = prize_pool_tier // len(tier_winners)
                    if amount_per_winner > 0:
                        remaining_jackpot -= (amount_per_winner * len(tier_winners)) # Tr·ª´ s·ªë ti·ªÅn th·ª±c t·∫ø ƒë√£ chia
                        for winner in tier_winners:
                            update_balance(winner['user_id'], amount_per_winner)
                            update_profile_stats(winner['user_id'], 0, amount_per_winner)
                            winners.append({'user_id': winner['user_id'], 'prize_tier': f"Gi·∫£i {match_count}", 'matched': match_count, 'amount': amount_per_winner})

        supabase.table('lottery_draws').insert({'draw_date': str(today), 'winning_numbers': winning_numbers, 'jackpot_amount': current_jackpot, 'winners': winners}).execute()
        print(f"ƒê√£ quay s·ªë xong cho ng√†y {today}. S·ªë tr√∫ng: {winning_numbers}. Jackpot: {current_jackpot}. Winners: {len(winners)}")
    except Exception as e: print(f"L·ªñI trong lottery_draw_task: {e}")

@lottery_draw_task.before_loop
async def before_lottery_task():
    await bot.wait_until_ready() # ƒê·∫£m b·∫£o bot s·∫µn s√†ng tr∆∞·ªõc khi task ch·∫°y

# --- ƒêO√ÅN S·ªê (GUESS THE NUMBER) ---
class GuessTheNumberGame:
    def __init__(self, interaction: discord.Interaction, bet_amount):
        self.interaction = interaction # L∆∞u interaction g·ªëc ƒë·ªÉ followup
        self.channel = interaction.channel
        self.host = interaction.user
        self.bet_amount = bet_amount
        self.number_to_guess = random.randint(1, 100)
        self.participants = {interaction.user.id} # Ng∆∞·ªùi kh·ªüi t·∫°o t·ª± ƒë·ªông tham gia
        self.guesses = {} # user_id: guess_value
        self.message: typing.Optional[discord.WebhookMessage] = None # S·∫Ω l√† followup message
        self.start_time = datetime.now(VIETNAM_TZ)
        self.duration = timedelta(minutes=2)
        self._task = None # Task ƒë·ªÉ k·∫øt th√∫c game

    async def start(self):
        embed = discord.Embed(title="ü§î ƒêo√°n S·ªë ü§î (1-100)", description=f"Game b·∫Øt ƒë·∫ßu! S·ªë ti·ªÅn c∆∞·ª£c m·ªói ng∆∞·ªùi: **{self.bet_amount:,}** ü™ô.\nƒêo√°n b·∫±ng l·ªánh `/guess number <s·ªë>`.\nC√≤n **2 ph√∫t**...", color=discord.Color.purple())
        embed.set_footer(text=f"Kh·ªüi t·∫°o b·ªüi {self.host.display_name}")
        # G·ª≠i b·∫±ng followup v√¨ start command ƒë√£ defer
        self.message = await self.interaction.followup.send(embed=embed, wait=True)
        # T·∫°o task ƒë·ªÉ t·ª± ƒë·ªông k·∫øt th√∫c
        self._task = asyncio.create_task(self.end_game_after_delay())

    async def end_game_after_delay(self):
        await asyncio.sleep(self.duration.total_seconds())
        # Ki·ªÉm tra xem game c√≤n t·ªìn t·∫°i kh√¥ng tr∆∞·ªõc khi k·∫øt th√∫c
        if bot.guess_the_number_game is self:
             await self.end_game()

    async def add_guess(self, interaction: discord.Interaction, guess: int):
        user = interaction.user
        if not (1 <= guess <= 100):
            await interaction.response.send_message("S·ªë ƒëo√°n ph·∫£i t·ª´ 1 ƒë·∫øn 100.", ephemeral=True, delete_after=5)
            return False

        if datetime.now(VIETNAM_TZ) > self.start_time + self.duration:
             await interaction.response.send_message("ƒê√£ h·∫øt gi·ªù ƒëo√°n!", ephemeral=True, delete_after=5)
             return False

        if user.id not in self.participants:
            user_data = get_user_data(user.id)
            if not user_data or user_data.get('balance',0) < self.bet_amount:
                await interaction.response.send_message(f"B·∫°n kh√¥ng ƒë·ªß {self.bet_amount:,} ü™ô ƒë·ªÉ tham gia!", ephemeral=True, delete_after=5)
                return False
            new_balance = update_balance(user.id, -self.bet_amount)
            if new_balance is None: await interaction.response.send_message("L·ªói tr·ª´ ti·ªÅn!", ephemeral=True); return False
            update_profile_stats(user.id, self.bet_amount, -self.bet_amount)
            self.participants.add(user.id)
            await interaction.response.send_message(f"B·∫°n ƒë√£ tham gia ƒëo√°n s·ªë v·ªõi {self.bet_amount:,} ü™ô. S·ªë d∆∞ m·ªõi: {new_balance:,} ü™ô.", ephemeral=True)
        else:
            # Ch·ªâ c·∫ßn x√°c nh·∫≠n n·∫øu ƒë√£ tham gia
             await interaction.response.defer(ephemeral=True, thinking=False) # Kh√¥ng g·ª≠i g√¨ c·∫£

        self.guesses[user.id] = guess

        if guess == self.number_to_guess:
            # H·ªßy task t·ª± ƒë·ªông k·∫øt th√∫c
            if self._task: self._task.cancel()
            await self.end_game(winner=user)
            return True
        elif guess < self.number_to_guess:
            await self.channel.send(f"{user.mention} ƒëo√°n `{guess}`: **CAO H∆†N!**", delete_after=10)
        else:
            await self.channel.send(f"{user.mention} ƒëo√°n `{guess}`: **TH·∫§P H∆†N!**", delete_after=10)
        return False

    async def end_game(self, winner: typing.Optional[discord.User] = None):
        global bot
        if bot.guess_the_number_game is not self: return # Game ƒë√£ k·∫øt th√∫c b·ªüi ng∆∞·ªùi kh√°c / task kh√°c
        bot.guess_the_number_game = None # ƒê√°nh d·∫•u game k·∫øt th√∫c

        total_pot = len(self.participants) * self.bet_amount
        try:
             embed = self.message.embeds[0] # L·∫•y embed hi·ªán t·∫°i
        except (AttributeError, IndexError): # N·∫øu message ho·∫∑c embed kh√¥ng t·ªìn t·∫°i
             embed = discord.Embed(title="ü§î ƒêo√°n S·ªë ü§î") # T·∫°o embed m·ªõi

        if winner:
            winnings = total_pot; net_gain = winnings - self.bet_amount # L·ªùi = T·ªïng pot - ti·ªÅn m√¨nh c∆∞·ª£c
            new_balance = update_balance(winner.id, winnings) # Tr·∫£ l·∫°i c·∫£ pot
            update_profile_stats(winner.id, 0, net_gain) # Ch·ªâ t√≠nh ph·∫ßn l·ªùi
            embed.title = f"üéâ {winner.display_name} ƒê√É ƒêO√ÅN TR√öNG S·ªê {self.number_to_guess}! üéâ"
            embed.description = f"Ch√∫c m·ª´ng {winner.mention} ƒë√£ th·∫Øng **{winnings:,}** ü™ô!\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
            embed.color = discord.Color.gold()
        else:
            embed.title = f"‚åõ H·∫æT GI·ªú! S·ªë c·∫ßn ƒëo√°n l√† {self.number_to_guess} ‚åõ"
            embed.description = "Kh√¥ng ai ƒëo√°n tr√∫ng. ƒê√£ ho√†n l·∫°i ti·ªÅn c∆∞·ª£c cho ng∆∞·ªùi tham gia."
            embed.color = discord.Color.dark_grey()
            # Ho√†n ti·ªÅn (ƒë√£ tr·ª´ l√∫c tham gia, gi·ªù c·ªông l·∫°i)
            for user_id in self.participants:
                update_balance(user_id, self.bet_amount)
                update_profile_stats(user_id, 0, self.bet_amount) # Ho√†n l·∫°i ti·ªÅn ƒë√£ t√≠nh l·ªó

        try:
             await self.message.edit(embed=embed)
        except Exception as e:
             print(f"L·ªói khi edit message k·∫øt th√∫c GuessTheNumber: {e}")
             # G·ª≠i tin nh·∫Øn m·ªõi n·∫øu edit l·ªói
             await self.channel.send(embed=embed)


guess_group = app_commands.Group(name="guess", description="L·ªánh ch∆°i game ƒëo√°n s·ªë")

@guess_group.command(name="start", description="B·∫Øt ƒë·∫ßu game ƒêo√°n S·ªë (1-100).")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn c∆∞·ª£c ƒë·ªÉ tham gia")
@global_rate_limit()
@is_user_not_in_game()
async def guess_the_number_start_slash(interaction: discord.Interaction, bet_amount: int):
    if bot.guess_the_number_game:
        await interaction.response.send_message("ƒêang c√≥ m·ªôt game ƒêo√°n S·ªë di·ªÖn ra r·ªìi!", ephemeral=True); return
    if bet_amount <= 0: await interaction.response.send_message("Ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!", ephemeral=True); return
    user_data = get_user_data(interaction.user.id)
    if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    if user_data.get('balance',0) < bet_amount: await interaction.response.send_message(f"B·∫°n kh√¥ng ƒë·ªß {bet_amount:,} ü™ô ƒë·ªÉ b·∫Øt ƒë·∫ßu game!", ephemeral=True); return

    await interaction.response.defer() # Defer tr∆∞·ªõc khi tr·ª´ ti·ªÅn v√† b·∫Øt ƒë·∫ßu game

    new_balance = update_balance(interaction.user.id, -bet_amount)
    if new_balance is None: await interaction.followup.send("L·ªói tr·ª´ ti·ªÅn!", ephemeral=True); return
    update_profile_stats(interaction.user.id, bet_amount, -bet_amount)

    bot.guess_the_number_game = GuessTheNumberGame(interaction, bet_amount)
    await bot.guess_the_number_game.start()

@guess_group.command(name="number", description="ƒêo√°n s·ªë trong game ƒêo√°n S·ªë ƒëang ch·∫°y.")
@app_commands.describe(number="S·ªë b·∫°n ƒëo√°n (1-100)")
@global_rate_limit() # V·∫´n √°p d·ª•ng rate limit chung
# Kh√¥ng c·∫ßn is_user_not_in_game ·ªü ƒë√¢y v√¨ ph·∫£i cho ph√©p ƒëo√°n khi ƒëang ch∆°i
async def guess_number_slash(interaction: discord.Interaction, number: int):
    if not bot.guess_the_number_game:
        await interaction.response.send_message("Hi·ªán kh√¥ng c√≥ game ƒêo√°n S·ªë n√†o ƒëang ch·∫°y.", ephemeral=True, delete_after=5); return

    # Th√™m l∆∞·ª£t ƒëo√°n (h√†m add_guess s·∫Ω t·ª± x·ª≠ l√Ω response)
    await bot.guess_the_number_game.add_guess(interaction, number)

bot.tree.add_command(guess_group)

# --- BLACKJACK (X√å D√ÅCH) ---
def create_deck(use_bj_ranks=True): # Th√™m tham s·ªë ƒë·ªÉ d√πng ƒë√∫ng rank
    deck = []
    ranks_to_use = CARD_RANKS_BJ if use_bj_ranks else CARD_RANKS_BACCARAT
    for suit in CARD_SUITS:
        for rank, value in ranks_to_use.items():
            deck.append({'rank': rank, 'suit': suit, 'value': value})
    random.shuffle(deck)
    return deck

def calculate_bj_score(hand): # ƒê·ªïi t√™n h√†m t√≠nh ƒëi·ªÉm BJ
    score = sum(card['value'] for card in hand)
    aces = sum(1 for card in hand if card['rank'] == 'A')
    while score > 21 and aces: score -= 10; aces -= 1 # A = 11 -> 1
    return score

def hand_to_string(hand): return " | ".join(f"**{c['rank']}{c['suit']}**" for c in hand)

class BlackjackView(ui.View):
    def __init__(self, author_id, game):
        super().__init__(timeout=300.0); self.author_id = author_id; self.game = game
    async def interaction_check(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.author_id: await interaction.response.send_message("ƒê√¢y kh√¥ng ph·∫£i v√°n b√†i c·ªßa b·∫°n!", ephemeral=True); return False
        return True
    async def on_timeout(self):
        # Ki·ªÉm tra xem game c√≥ th·ª±c s·ª± c√≤n trong dict kh√¥ng tr∆∞·ªõc khi pop
        if self.author_id in bot.blackjack_games and bot.blackjack_games[self.author_id] == self.game:
            game = bot.blackjack_games.pop(self.author_id); embed = game['embed']
            embed.title = "üÉè X√¨ D√°ch (H·∫øt gi·ªù) üÉè"; embed.description = "B·∫°n ƒë√£ kh√¥ng ph·∫£n h·ªìi. V√°n b√†i b·ªã h·ªßy."; embed.color = discord.Color.dark_grey()
            for item in self.children: item.disabled = True
            try: await game['message'].edit(embed=embed, view=self)
            except discord.NotFound: pass # B·ªè qua n·∫øu tin nh·∫Øn b·ªã x√≥a
    async def end_game(self, interaction: typing.Optional[discord.Interaction], result_text: str, payout: int):
        user_id = self.author_id
        # Ch·ªâ pop game n·∫øu n√≥ v·∫´n c√≤n trong dict v√† l√† game hi·ªán t·∫°i
        if user_id not in bot.blackjack_games or bot.blackjack_games[user_id] != self.game: return # Game ƒë√£ k·∫øt th√∫c ho·∫∑c timeout
        game_data = bot.blackjack_games.pop(user_id) # L·∫•y v√† x√≥a game

        new_balance = update_balance(user_id, payout)
        # Update stats ch·ªâ khi game k·∫øt th√∫c (kh√¥ng ph·∫£i timeout)
        if interaction: update_profile_stats(user_id, game_data['bet'], payout)

        embed = game_data['embed']; embed.title = f"üÉè X√¨ D√°ch ({result_text}) üÉè"
        embed.color = discord.Color.green() if payout > 0 else (discord.Color.red() if payout < 0 else discord.Color.light_grey())
        dealer_score = calculate_bj_score(game_data['dealer_hand'])
        embed.set_field_at(0, name=f"B√†i Dealer ({dealer_score})", value=hand_to_string(game_data['dealer_hand']), inline=False)
        if payout > 0: embed.description = f"üéâ **B·∫°n th·∫Øng {abs(payout):,} ü™ô!**\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
        elif payout < 0: embed.description = f"üò¢ **B·∫°n thua {abs(payout):,} ü™ô!**\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
        else: embed.description = f"‚öñÔ∏è **H√≤a (Push)!**\nB·∫°n ƒë∆∞·ª£c ho√†n ti·ªÅn. S·ªë d∆∞: **{new_balance:,}** ü™ô."
        for item in self.children: item.disabled = True
        # N·∫øu interaction t·ªìn t·∫°i (k·∫øt th√∫c do ng∆∞·ªùi ch∆°i), d√πng response.edit
        if interaction: await interaction.response.edit_message(embed=embed, view=self)
        # N·∫øu interaction l√† None (k·∫øt th√∫c do timeout ho·∫∑c l·ªói kh√°c), d√πng message.edit
        else:
             try: await game_data['message'].edit(embed=embed, view=self)
             except discord.NotFound: pass # B·ªè qua n·∫øu tin nh·∫Øn b·ªã x√≥a
    @ui.button(label="R√∫t (Hit)", style=discord.ButtonStyle.primary, emoji="‚ûï")
    async def hit(self, interaction: discord.Interaction, button: ui.Button):
        if self.author_id not in bot.blackjack_games or bot.blackjack_games[self.author_id] != self.game: return # Ki·ªÉm tra game c√≤n t·ªìn t·∫°i
        game = self.game; game['player_hand'].append(game['deck'].pop()); player_score = calculate_bj_score(game['player_hand'])
        embed = game['embed']; embed.set_field_at(1, name=f"B√†i c·ªßa b·∫°n ({player_score})", value=hand_to_string(game['player_hand']), inline=False)
        if player_score > 21: await self.end_game(interaction, "B·∫°n b·ªã Qu·∫Øc!", -game['bet'])
        else: self.children[2].disabled = True; await interaction.response.edit_message(embed=embed, view=self)
    @ui.button(label="D·∫±n (Stand)", style=discord.ButtonStyle.secondary, emoji="üõë")
    async def stand(self, interaction: discord.Interaction, button: ui.Button):
        if self.author_id not in bot.blackjack_games or bot.blackjack_games[self.author_id] != self.game: return
        game = self.game; dealer_hand = game['dealer_hand']; dealer_score = calculate_bj_score(dealer_hand)
        # Dealer r√∫t b√†i theo lu·∫≠t (r√∫t khi <= 16, d·ª´ng khi >= 17)
        while dealer_score < 17:
             if not game['deck']: break # H·∫øt b√†i
             dealer_hand.append(game['deck'].pop()); dealer_score = calculate_bj_score(dealer_hand)
        player_score = calculate_bj_score(game['player_hand'])
        if dealer_score > 21: await self.end_game(interaction, "Dealer b·ªã Qu·∫Øc!", game['bet']) # Th·∫Øng 1:1
        elif dealer_score > player_score: await self.end_game(interaction, "Dealer th·∫Øng!", -game['bet'])
        elif player_score > dealer_score: await self.end_game(interaction, "B·∫°n th·∫Øng!", game['bet']) # Th·∫Øng 1:1
        else: await self.end_game(interaction, "H√≤a!", 0) # H√≤a (Push)
    @ui.button(label="G·∫•p ƒë√¥i (Double)", style=discord.ButtonStyle.success, emoji="‚úñÔ∏è2")
    async def double(self, interaction: discord.Interaction, button: ui.Button):
        if self.author_id not in bot.blackjack_games or bot.blackjack_games[self.author_id] != self.game: return
        game = self.game; user_id = self.author_id; user_data = get_user_data(user_id)
        if not user_data or user_data.get('balance', 0) < game['bet'] * 2: await interaction.response.send_message("B·∫°n kh√¥ng ƒë·ªß ti·ªÅn ƒë·ªÉ G·∫•p ƒë√¥i!", ephemeral=True); return
        if not game['deck']: await interaction.response.send_message("H·∫øt b√†i ƒë·ªÉ r√∫t!", ephemeral=True); return # Check h·∫øt b√†i

        game['bet'] *= 2; game['player_hand'].append(game['deck'].pop()); player_score = calculate_bj_score(game['player_hand'])
        embed = game['embed']; embed.set_field_at(1, name=f"B√†i c·ªßa b·∫°n ({player_score})", value=hand_to_string(game['player_hand']), inline=False)
        embed.set_footer(text=f"ƒê√É G·∫§P ƒê√îI! C∆∞·ª£c: {game['bet']:,} ü™ô")
        if player_score > 21: await self.end_game(interaction, "B·∫°n b·ªã Qu·∫Øc!", -game['bet']) # Thua ti·ªÅn c∆∞·ª£c g·∫•p ƒë√¥i
        else: await self.stand(interaction, button) # T·ª± ƒë·ªông d·∫±n sau khi double

@bot.slash_command(name="blackjack", description="Ch∆°i X√¨ D√°ch (Blackjack) v·ªõi bot.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn b·∫°n mu·ªën c∆∞·ª£c")
@global_rate_limit()
@is_user_not_in_game()
async def blackjack_slash(interaction: discord.Interaction, bet_amount: int):
    await interaction.response.defer()
    user_id = interaction.user.id; user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)
    if bet_amount <= 0: await interaction.followup.send('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.followup.send(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return

    deck = create_deck(use_bj_ranks=True); player_hand = [deck.pop(), deck.pop()]; dealer_hand = [deck.pop(), deck.pop()]
    player_score = calculate_bj_score(player_hand); dealer_score_show_one = dealer_hand[0]['value'] if dealer_hand[0]['rank'] != 'A' else 11 # ƒêi·ªÉm l√° ƒë·∫ßu c·ªßa dealer
    embed = discord.Embed(title="üÉè X√¨ D√°ch üÉè", description="Ch·ªçn h√†nh ƒë·ªông c·ªßa b·∫°n.", color=discord.Color.blue())
    embed.add_field(name=f"B√†i Dealer ({dealer_score_show_one if dealer_score_show_one <= 10 else 'A'})", value=f"**{dealer_hand[0]['rank']}{dealer_hand[0]['suit']}** | **[ ? ]**", inline=False) # Hi·ªán ƒëi·ªÉm l√° ƒë·∫ßu
    embed.add_field(name=f"B√†i c·ªßa b·∫°n ({player_score})", value=hand_to_string(player_hand), inline=False)
    embed.set_footer(text=f"Ti·ªÅn c∆∞·ª£c: {bet_amount:,} ü™ô");

    # T·∫°o View v√† ki·ªÉm tra Blackjack ban ƒë·∫ßu
    game_state = {'bet': bet_amount, 'deck': deck, 'player_hand': player_hand, 'dealer_hand': dealer_hand, 'message': None, 'embed': embed} # message s·∫Ω ƒë∆∞·ª£c set sau
    view = BlackjackView(user_id, game_state)

    if player_score == 21: # Blackjack!
        winnings = int(bet_amount * 1.5); payout = winnings
        new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)
        embed.title = "üÉè BLACKJACK! üÉè"; embed.description = f"üéâ **B·∫°n th·∫Øng {winnings:,} ü™ô!**\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
        embed.color = discord.Color.gold(); dealer_final_score = calculate_bj_score(dealer_hand); embed.set_field_at(0, name=f"B√†i Dealer ({dealer_final_score})", value=hand_to_string(dealer_hand), inline=False)
        for item in view.children: item.disabled = True
        await interaction.followup.send(embed=embed, view=view)
    else: # Game ti·∫øp t·ª•c b√¨nh th∆∞·ªùng
        # V√¥ hi·ªáu h√≥a n√∫t Double n·∫øu kh√¥ng ƒë·ªß ti·ªÅn
        if balance < bet_amount * 2:
            view.children[2].disabled = True
        message = await interaction.followup.send(embed=embed, view=view, wait=True)
        game_state['message'] = message
        bot.blackjack_games[user_id] = game_state # L∆∞u state sau khi g·ª≠i message

# --- MINES (D√í M√åN) ---
def combinations(n, k):
    if k < 0 or k > n: return 0
    if k == 0 or k == n: return 1
    if k > n // 2: k = n - k
    # T·ªëi ∆∞u h√≥a t√≠nh to√°n t·ªï h·ª£p
    res = 1
    for i in range(k):
        res = res * (n - i) // (i + 1)
    return res

def calculate_mines_payout(gems_revealed, total_bombs):
    total_cells = 25
    if gems_revealed <= 0: return 1.0
    # ƒê·∫£m b·∫£o gems_revealed kh√¥ng v∆∞·ª£t qu√° s·ªë kim c∆∞∆°ng c√≥ th·ªÉ c√≥
    max_gems = total_cells - total_bombs
    if gems_revealed > max_gems: return calculate_mines_payout(max_gems, total_bombs) # T√≠nh theo max gems n·∫øu l·ª° >

    numerator = combinations(total_cells, gems_revealed)
    denominator = combinations(max_gems, gems_revealed)
    if denominator == 0: return 1.0 # Tr√°nh chia cho 0
    payout_multiplier = (numerator / denominator) * 0.95 # 95% House Edge
    # Gi·ªõi h·∫°n payout t·ªëi ƒëa ƒë·ªÉ tr√°nh s·ªë qu√° l·ªõn (v√≠ d·ª•: 10000x)
    return min(payout_multiplier, 10000.0)


class MinesButton(ui.Button):
    def __init__(self, x, y):
        super().__init__(style=discord.ButtonStyle.secondary, label="\u200b", row=x); self.x = x; self.y = y
    async def callback(self, interaction: discord.Interaction):
        user_id = interaction.user.id
        if user_id not in bot.mines_games: await interaction.response.send_message("ƒê√¢y kh√¥ng ph·∫£i game c·ªßa b·∫°n!", ephemeral=True); return
        game_view = self.view
        if user_id != game_view.author_id: await interaction.response.send_message("ƒê√¢y kh√¥ng ph·∫£i game c·ªßa b·∫°n!", ephemeral=True); return

        game = bot.mines_games[user_id]; index = self.x * 5 + self.y
        if game['grid'][index] == 'üí£':
            self.style = discord.ButtonStyle.danger; self.label = 'üí£'; self.disabled = True
            payout = -game['bet']; new_balance = update_balance(user_id, payout)
            update_profile_stats(user_id, game['bet'], payout)
            embed = game['embed']; embed.title = "üí• B√ôM! B·∫†N ƒê√É THUA! üí•"; embed.description = f"B·∫°n l·∫≠t tr√∫ng bom!\nB·∫°n m·∫•t **{game['bet']:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
            embed.color = discord.Color.red(); game_view.stop_game(show_solution=True)
            await interaction.response.edit_message(embed=embed, view=game_view); bot.mines_games.pop(user_id, None)
        else: # Tr√∫ng kim c∆∞∆°ng
            self.style = discord.ButtonStyle.success; self.label = 'üíé'; self.disabled = True; game['revealed_count'] += 1
            payout_multiplier = calculate_mines_payout(game['revealed_count'], game['bomb_count']); game['current_payout'] = payout_multiplier
            winnings = int(game['bet'] * (payout_multiplier - 1)); embed = game['embed']
            embed.description = f"T√¨m th·∫•y **{game['revealed_count']}** üíé. L·∫≠t ti·∫øp ho·∫∑c R√∫t ti·ªÅn!"
            embed.set_field_at(1, name="H·ªá s·ªë Hi·ªán T·∫°i", value=f"{payout_multiplier:.2f}x")
            embed.set_field_at(2, name="Ti·ªÅn th·∫Øng (n·∫øu r√∫t)", value=f"{winnings:,} ü™ô")
            game_view.children[-1].label = f"R√∫t ti·ªÅn ({payout_multiplier:.2f}x | {winnings:,} ü™ô)" # C·∫≠p nh·∫≠t n√∫t cashout

            if game['revealed_count'] == (25 - game['bomb_count']): # Th·∫Øng tuy·ªát ƒë·ªëi
                net_gain = winnings # Th·∫Øng ph·∫ßn l·ªùi
                new_balance = update_balance(user_id, net_gain) # C·ªông ph·∫ßn l·ªùi
                update_profile_stats(user_id, game['bet'], net_gain)
                embed.title = "üéâ B·∫†N ƒê√É TH·∫ÆNG TUY·ªÜT ƒê·ªêI! üéâ"; embed.description = f"B·∫°n ƒë√£ t√¨m th·∫•y t·∫•t c·∫£ {game['revealed_count']} üíé!\nB·∫°n th·∫Øng **{winnings:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
                embed.color = discord.Color.gold(); game_view.stop_game(show_solution=False)
                await interaction.response.edit_message(embed=embed, view=game_view); bot.mines_games.pop(user_id, None)
            else: # Ti·∫øp t·ª•c ch∆°i
                await interaction.response.edit_message(embed=embed, view=game_view)

class MinesCashoutButton(ui.Button):
    def __init__(self): super().__init__(style=discord.ButtonStyle.primary, label="R√∫t ti·ªÅn (1.00x)", row=4)
    async def callback(self, interaction: discord.Interaction):
        user_id = interaction.user.id
        if user_id not in bot.mines_games: await interaction.response.send_message("ƒê√¢y kh√¥ng ph·∫£i game c·ªßa b·∫°n!", ephemeral=True); return
        game_view = self.view
        if user_id != game_view.author_id: await interaction.response.send_message("ƒê√¢y kh√¥ng ph·∫£i game c·ªßa b·∫°n!", ephemeral=True); return
        game = bot.mines_games[user_id]
        if game['revealed_count'] == 0: await interaction.response.send_message("B·∫°n ph·∫£i l·∫≠t √≠t nh·∫•t 1 √¥!", ephemeral=True); return

        winnings = int(game['bet'] * (game['current_payout'] - 1)); net_gain = winnings
        new_balance = update_balance(user_id, net_gain) # Ch·ªâ c·ªông ph·∫ßn l·ªùi
        update_profile_stats(user_id, game['bet'], net_gain)
        embed = game['embed']; embed.title = "‚úÖ R√öT TI·ªÄN TH√ÄNH C√îNG ‚úÖ"
        embed.description = f"B·∫°n r√∫t ti·ªÅn t·∫°i **{game['current_payout']:.2f}x**.\nB·∫°n th·∫Øng **{winnings:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."
        embed.color = discord.Color.green(); game_view.stop_game(show_solution=True)
        await interaction.response.edit_message(embed=embed, view=game_view); bot.mines_games.pop(user_id, None)

class MinesView(ui.View):
    def __init__(self, author_id, game):
        super().__init__(timeout=300.0); self.author_id = author_id; self.game = game
        button_index = 0
        for x in range(5):
            for y in range(5):
                 # H√†ng cu·ªëi c√πng (row 4) ch·ªâ c√≥ 4 n√∫t + cashout
                 if x == 4 and y == 4:
                      self.add_item(MinesCashoutButton())
                 else:
                      self.add_item(MinesButton(x, y))
                 button_index += 1

    async def on_timeout(self):
        if self.author_id in bot.mines_games and bot.mines_games[self.author_id] == self.game:
            game = bot.mines_games.pop(self.author_id); embed = game['embed']
            embed.title = "üí£ D√≤ M√¨n (H·∫øt gi·ªù) üí£"; embed.description = "B·∫°n ƒë√£ kh√¥ng ph·∫£n h·ªìi. V√°n game b·ªã h·ªßy. B·∫°n kh√¥ng m·∫•t ti·ªÅn c∆∞·ª£c." # Kh√¥ng m·∫•t ti·ªÅn n·∫øu timeout
            embed.color = discord.Color.dark_grey(); self.stop_game(show_solution=False)
            try: await game['message'].edit(embed=embed, view=self)
            except discord.NotFound: pass

    def stop_game(self, show_solution: bool):
        game = self.game; button_index = 0
        for item in self.children:
            item.disabled = True
            if isinstance(item, MinesButton):
                grid_index = item.x * 5 + item.y
                if show_solution:
                    if game['grid'][grid_index] == 'üí£': item.label = 'üí£'; item.style = discord.ButtonStyle.danger
                    elif game['grid'][grid_index] == 'üíé': item.label = 'üíé'; item.style = discord.ButtonStyle.secondary if item.style != discord.ButtonStyle.success else item.style

@bot.slash_command(name="mines", description="Ch∆°i D√≤ M√¨n.")
@app_commands.describe(bet_amount="S·ªë ti·ªÅn b·∫°n mu·ªën c∆∞·ª£c", bomb_count="S·ªë l∆∞·ª£ng bom (1-24)")
@global_rate_limit()
@is_user_not_in_game()
async def mines_slash(interaction: discord.Interaction, bet_amount: int, bomb_count: app_commands.Range[int, 1, 24]):
    await interaction.response.defer()
    user_id = interaction.user.id; user_data = get_user_data(user_id)
    if not user_data: await interaction.followup.send("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
    balance = user_data.get('balance', 0)
    if bet_amount <= 0: await interaction.followup.send('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!', ephemeral=True); return
    if balance < bet_amount: await interaction.followup.send(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.', ephemeral=True); return
    # Kh√¥ng tr·ª´ ti·ªÅn ngay, ch·ªâ tr·ª´ khi thua ho·∫∑c c·ªông l·ªùi khi th·∫Øng/cashout

    grid = ['üí£'] * bomb_count + ['üíé'] * (25 - bomb_count); random.shuffle(grid)
    embed = discord.Embed(title=f"üí£ D√≤ M√¨n ({bomb_count} bom) üí£", description="L·∫≠t c√°c √¥ ƒë·ªÉ t√¨m kim c∆∞∆°ng üíé. ƒê·ª´ng tr√∫ng bom üí£!", color=discord.Color.blue())
    embed.add_field(name="Ti·ªÅn c∆∞·ª£c", value=f"**{bet_amount:,}** ü™ô")
    embed.add_field(name="H·ªá s·ªë Hi·ªán T·∫°i", value="1.00x")
    embed.add_field(name="Ti·ªÅn th·∫Øng (n·∫øu r√∫t)", value="0 ü™ô")
    game_state = {'bet': bet_amount, 'bomb_count': bomb_count, 'grid': grid, 'revealed_count': 0, 'current_payout': 1.0, 'message': None, 'embed': embed}
    view = MinesView(user_id, game_state); message = await interaction.followup.send(embed=embed, view=view, wait=True)
    game_state['message'] = message; bot.mines_games[user_id] = game_state



# --- X·ªî S·ªê (LOTTERY) - SLASH COMMANDS & TASK ---
# ... (D√°n code lottery_group v√† lottery_draw_task ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi) ...

# --- ƒêO√ÅN S·ªê (GUESS THE NUMBER) - SLASH COMMANDS ---
# ... (D√°n code Class GuessTheNumberGame v√† guess_group ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi) ...

# --- GAME GIAO DI·ªÜN UI (BLACKJACK & MINES) - SLASH COMMANDS ---
# ... (D√°n code Blackjack v√† Mines ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi sang Slash Commands) ...

# --- V√íNG QUAY MAY M·∫ÆN (SPIN THE WHEEL) - SLASH COMMAND ---
# ... (D√°n code Spin the Wheel ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi sang Slash Commands) ...

# --- CH·∫†Y BOT ---
if __name__ == "__main__":
    if TOKEN:
        keep_alive();
        try: bot.run(TOKEN)
        except Exception as e: print(f"L·ªói khi ch·∫°y bot: {e}")
    else:
        print("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_TOKEN")
