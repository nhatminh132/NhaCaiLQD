# -*- coding: utf-8 -*-
import discord
from discord.ext import commands, tasks
from discord import ui
import os
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone, date, time
from supabase import create_client, Client
import typing
import random
import asyncio
import math
import discord.utils
import pytz # Th√™m th∆∞ vi·ªán m√∫i gi·ªù
import re # Th√™m th∆∞ vi·ªán regex cho c∆∞·ª£c Roulette ph·ª©c t·∫°p

# Import t·ªáp keep_alive
from keep_alive import keep_alive

# --- T·∫£i Token v√† C√†i ƒë·∫∑t Bot ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_KEY = os.getenv('SUPABASE_KEY')

# --- C√†i ƒë·∫∑t Supabase ---
if not SUPABASE_URL or not SUPABASE_KEY: print("L·ªñI: Kh√¥ng t√¨m th·∫•y SUPABASE_URL ho·∫∑c SUPABASE_KEY"); exit()
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# C√†i ƒë·∫∑t Bot Discord
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
bot = commands.Bot(command_prefix='!', intents=intents, help_command=None)

# --- BI·∫æN TO√ÄN C·ª§C CHO GAME ---
game_message = None # Tin nh·∫Øn game T√†i X·ªâu
game_channel_id = None # K√™nh game T√†i X·ªâu
current_bets = {} # C∆∞·ª£c v√°n T√†i X·ªâu hi·ªán t·∫°i
bot.blackjack_games = {} # L∆∞u c√°c v√°n Blackjack
bot.mines_games = {} # L∆∞u c√°c v√°n D√≤ M√¨n
bot.users_in_animation = set() # D√πng ƒë·ªÉ kh√≥a l·ªánh khi game c√≥ hi·ªáu ·ª©ng
bot.guess_the_number_game = None # L∆∞u state game ƒêo√°n S·ªë

# --- ƒê·ªäNH NGHƒ®A H·∫∞NG S·ªê ---
STARTING_TOKENS = 100
DAILY_REWARD = 50
DAILY_COOLDOWN_HOURS = 24
ADMIN_ROLE = "Bot Admin"
VIETNAM_TZ = pytz.timezone('Asia/Ho_Chi_Minh') # M√∫i gi·ªù VN
LOTTERY_DRAW_TIME = time(18, 0, 0, tzinfo=VIETNAM_TZ) # 18:00 VN h√†ng ng√†y
LOTTERY_TICKET_PRICE = 100 # Gi√° v√© s·ªë

# Roulette
RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]
BLACK_NUMBERS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35]
# C∆∞·ª£c Roulette ph·ª©c t·∫°p (Payout rate)
ROULETTE_PAYOUTS = {
    'single': 35, 'split': 17, 'street': 11, 'corner': 8, 'sixline': 5,
    'dozen': 2, 'column': 2, # Dozen/Column th·ª±c ra l√† 1 ƒÉn 2
    'color': 1, 'evenodd': 1, 'half': 1 # C√°c c∆∞·ª£c 1 ƒÉn 1
}

# B·∫ßu Cua
BAU_CUA_FACES = {'b·∫ßu': 'B·∫ßu üçê', 'bau': 'B·∫ßu üçê', 'üçê': 'B·∫ßu üçê', 'cua': 'Cua ü¶Ä', 'ü¶Ä': 'Cua ü¶Ä', 't√¥m': 'T√¥m ü¶ê', 'tom': 'T√¥m ü¶ê', 'ü¶ê': 'T√¥m ü¶ê', 'c√°': 'C√° üêü', 'ca': 'C√° üêü', 'üêü': 'C√° üêü', 'g√†': 'G√† üêì', 'ga': 'G√† üêì', 'üêì': 'G√† üêì', 'nai': 'Nai ü¶å', 'ü¶å': 'Nai ü¶å'}
BAU_CUA_LIST = ['B·∫ßu üçê', 'Cua ü¶Ä', 'T√¥m ü¶ê', 'C√° üêü', 'G√† üêì', 'Nai ü¶å']

# ƒêua Ng·ª±a
NUM_HORSES = 6; RACE_LENGTH = 20

# M√°y X√®ng (Slots)
SLOT_SYMBOLS = [('üçí', 10, 10), ('üçã', 9, 15), ('üçä', 8, 20), ('üçì', 5, 30), ('üîî', 3, 50), ('üíé', 2, 100), ('7Ô∏è‚É£', 1, 200)]
SLOT_WHEEL, SLOT_WEIGHTS, SLOT_PAYOUTS = [], [], {}
for (symbol, weight, payout) in SLOT_SYMBOLS: SLOT_WHEEL.append(symbol); SLOT_WEIGHTS.append(weight); SLOT_PAYOUTS[symbol] = payout

# B√†i (Cards)
CARD_SUITS = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è']
# J=10, Q=10, K=10, A=1 (Baccarat), A=11/1 (BJ), A=14 (Hilo)
CARD_RANKS_BACCARAT = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 0, 'J': 0, 'Q': 0, 'K': 0, 'A': 1}
CARD_RANKS_BJ = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
CARD_RANKS_HILO = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}


# --- C√ÄI ƒê·∫∂T RATE LIMIT TO√ÄN C·ª§C ---
global_cooldown = commands.CooldownMapping.from_cooldown(30, 60.0, commands.BucketType.default)

# --- QU·∫¢N L√ù D·ªÆ LI·ªÜU (SUPABASE) ---
def get_user_data(user_id: int) -> typing.Dict:
    try:
        response = supabase.table('profiles').select('*').eq('user_id', user_id).single().execute()
        # Ki·ªÉm tra xem c√°c c·ªôt stats ƒë√£ t·ªìn t·∫°i ch∆∞a, n·∫øu ch∆∞a th√¨ th√™m gi√° tr·ªã m·∫∑c ƒë·ªãnh
        data = response.data
        if 'total_bet' not in data: data['total_bet'] = 0
        if 'total_won' not in data: data['total_won'] = 0
        if 'games_played' not in data: data['games_played'] = 0
        return data
    except Exception as e:
        if "JSON object requested" in str(e): # User ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
             try:
                 insert_response = supabase.table('profiles').insert({'user_id': user_id, 'balance': STARTING_TOKENS, 'last_daily': None, 'used_codes': [], 'total_bet': 0, 'total_won': 0, 'games_played': 0}).execute()
                 return insert_response.data[0]
             except Exception as e2: print(f"L·ªói khi t·∫°o user m·ªõi {user_id}: {e2}"); return None
        else: print(f"L·ªói khi get_user_data cho {user_id}: {e}"); return None

def update_balance(user_id: int, amount: int) -> typing.Optional[int]:
    try:
        response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
        return response.data
    except Exception as e:
        print(f"L·ªói khi update_balance cho {user_id}: {e}")
        user_data = get_user_data(user_id) # Th·ª≠ t·∫°o/l·∫•y l·∫°i user
        if user_data:
             try:
                 response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
                 return response.data
             except Exception as e2: print(f"L·ªói l·∫ßn 2 khi update_balance: {e2}")
        return None

def update_profile_stats(user_id: int, bet_amount: int, net_gain: int):
    try:
        current_stats = supabase.table('profiles').select('total_bet', 'total_won', 'games_played').eq('user_id', user_id).single().execute().data
        if not current_stats: return # User kh√¥ng t·ªìn t·∫°i (ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ·ªü get_user_data nh∆∞ng check l·∫°i cho ch·∫Øc)

        # S·ª≠ d·ª•ng .get() v·ªõi gi√° tr·ªã m·∫∑c ƒë·ªãnh 0 ƒë·ªÉ tr√°nh l·ªói n·∫øu c·ªôt ch∆∞a c√≥
        new_total_bet = current_stats.get('total_bet', 0) + bet_amount
        new_total_won = current_stats.get('total_won', 0) + max(0, net_gain) # Ch·ªâ c·ªông ph·∫ßn l·ªùi
        new_games_played = current_stats.get('games_played', 0) + 1

        supabase.table('profiles').update({
            'total_bet': new_total_bet,
            'total_won': new_total_won,
            'games_played': new_games_played
        }).eq('user_id', user_id).execute()
    except Exception as e: print(f"L·ªói khi update_profile_stats cho {user_id}: {e}")

def get_jackpot_pool(game_name: str):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        data = supabase.table(table_name).select('pool_amount').eq('game_name', game_name).single().execute().data
        return data['pool_amount'] if data else 0
    except Exception as e: print(f"L·ªói khi l·∫•y jackpot {game_name}: {e}"); return 0

def update_jackpot_pool(game_name: str, amount: int):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        # S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p an to√†n h∆°n ƒë·ªÉ c·∫≠p nh·∫≠t (atomic increment) n·∫øu Supabase h·ªó tr·ª£
        # T·∫°m th·ªùi v·∫´n d√πng ƒë·ªçc-ghi
        current_pool = get_jackpot_pool(game_name)
        new_pool = max(0, current_pool + amount)
        supabase.table(table_name).update({'pool_amount': new_pool}).eq('game_name', game_name).execute()
        return new_pool
    except Exception as e: print(f"L·ªói khi c·∫≠p nh·∫≠t jackpot {game_name}: {e}"); return get_jackpot_pool(game_name)

def get_taixiu_history():
    try:
        data = supabase.table('jackpot').select('history').eq('game_name', 'taixiu').single().execute().data
        return data.get('history', [])[-10:] # D√πng get ƒë·ªÉ an to√†n h∆°n
    except Exception as e: print(f"Loi khi lay history taixiu: {e}"); return []

# --- H√ÄM KI·ªÇM TRA & S·ª∞ KI·ªÜN BOT ---
@bot.before_invoke
async def global_check_before_command(ctx):
    command = ctx.command
    if command and command.name == 'help': return
    bucket = global_cooldown.get_bucket(ctx.message)
    retry_after = bucket.update_rate_limit()
    if retry_after: raise commands.CommandOnCooldown(bucket, retry_after, commands.BucketType.default)

@bot.event
async def on_ready():
    bot.add_view(TaiXiuGameView()) # ƒêƒÉng k√Ω view T√†i X·ªâu
    # ƒêƒÉng k√Ω c√°c view kh√°c n·∫øu c·∫ßn (v√≠ d·ª• Blackjack, Mines - nh∆∞ng ch√∫ng d√πng timeout n√™n kh√¥ng c·∫ßn thi·∫øt)
    lottery_draw_task.start()
    print(f'Bot {bot.user.name} ƒë√£ s·∫µn s√†ng!')
    print('------')

@bot.event
async def on_command_error(ctx, error):
    command_name = ctx.command.name if ctx.command else "Unknown"
    if isinstance(error, commands.CommandOnCooldown):
        seconds = error.retry_after; await ctx.send(f"‚è≥ Bot ƒëang x·ª≠ l√Ω qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng th·ª≠ l·∫°i sau **{seconds:.1f} gi√¢y**.", delete_after=5)
    elif isinstance(error, commands.MissingRole):
        await ctx.send(f"R·∫•t ti·∫øc {ctx.author.mention}, b·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y. C·∫ßn role `{ADMIN_ROLE}`.")
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send(f'C√∫ ph√°p sai! G√µ `!help` ƒë·ªÉ xem h∆∞·ªõng d·∫´n l·ªánh `{command_name}`.')
    elif isinstance(error, commands.BadArgument):
        if command_name in ['admin_give', 'admin_set', 'chuyenxu', 'profile', 'admin_view', 'admin_resetdaily']: await ctx.send('Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ƒë√≥ ho·∫∑c s·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá.')
        elif command_name == 'lottery_buy': await ctx.send('Vui l√≤ng nh·∫≠p 6 s·ªë h·ª£p l·ªá (1-45).')
        elif command_name == 'admin_announce': await ctx.send('Kh√¥ng t√¨m th·∫•y k√™nh ƒë√≥.')
        else: await ctx.send('S·ªë ti·ªÅn c∆∞·ª£c ho·∫∑c s·ªë ƒëo√°n/s·ªë ng·ª±a/s·ªë bom/l·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá.')
    elif isinstance(error, commands.CheckFailure):
        await ctx.send(f"‚è≥ {ctx.author.mention}, b·∫°n ƒëang c√≥ m·ªôt tr√≤ ch∆°i kh√°c ƒëang ch·∫°y. Vui l√≤ng ch·ªù cho n√≥ k·∫øt th√∫c!", ephemeral=True, delete_after=5)
    # X·ª≠ l√Ω l·ªói c·ª• th·ªÉ cho Roulette c∆∞·ª£c ph·ª©c t·∫°p
    elif isinstance(error, commands.CommandInvokeError) and isinstance(error.original, ValueError) and "Invalid Roulette bet type" in str(error.original):
         await ctx.send(f"Lo·∫°i c∆∞·ª£c Roulette kh√¥ng h·ª£p l·ªá: `{ctx.message.content.split(' ')[-1]}`. G√µ `!help` xem v√≠ d·ª•.")
    else:
        print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ l·ªánh '{command_name}': {error}")
        await ctx.send('ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i sau.')

def is_user_in_game(ctx):
    user_id = ctx.author.id
    if user_id in bot.blackjack_games: return False
    if user_id in bot.mines_games: return False
    if bot.guess_the_number_game and user_id in bot.guess_the_number_game.participants: return False
    if user_id in bot.users_in_animation: return False
    return True

# --- L·ªÜNH !HELP ---
@bot.command(name='help')
async def custom_help(ctx):
    embed = discord.Embed(title="Tr·ª£ gi√∫p Bot Casino üé∞", color=discord.Color.gold())
    embed.add_field(name="ü™ô L·ªánh C∆° b·∫£n", value="`!help`\n`!kiemtra` (`!bal`, `!sodu`)\n`!daily`\n`!code <m√£>`\n`!chuyenxu @user <s·ªë_ti·ªÅn>`\n`!bangxephang` (`!top`)\n`!profile [@user]` - Xem h·ªì s∆°", inline=False)
    embed.add_field(name="üé≤ Tr√≤ ch∆°i (G√µ l·ªánh)", value="`!slots <s·ªë_ti·ªÅn>` - Ch∆°i m√°y x√®ng.\n`!hilo <s·ªë_ti·ªÅn> <cao/th·∫•p>` - ƒêo√°n l√° b√†i ti·∫øp theo.\n`!tungxu <s·ªë_ti·ªÅn> <s·∫•p/ng·ª≠a>` - C∆∞·ª£c 50/50.\n`!xucxac <s·ªë_ti·ªÅn> <s·ªë_ƒëo√°n>` - ƒêo√°n s·ªë (1-6), th·∫Øng 1 ƒÉn 5.\n`!baucua <s·ªë_ti·ªÅn> <linh_v·∫≠t>` - C∆∞·ª£c B·∫ßu Cua T√¥m C√°.\n`!duangua <s·ªë_ti·ªÅn> <s·ªë_ng·ª±a>` - C∆∞·ª£c ƒëua ng·ª±a (1-6), th·∫Øng 1 ƒÉn 4.\n`!quay <s·ªë_ti·ªÅn> <lo·∫°i_c∆∞·ª£c>` - Ch∆°i Roulette.\n`!baccarat <s·ªë_ti·ªÅn> <player/banker/tie>`\n`!lottery buy <s1>..<s6>` - Mua v√© s·ªë (1-45)\n`!lottery result` - Xem k·∫øt qu·∫£ XS\n`!guessthenumber start <s·ªë_ti·ªÅn>` - B·∫Øt ƒë·∫ßu ƒëo√°n s·ªë\n`!guess <s·ªë>` - ƒêo√°n s·ªë (1-100)", inline=False)
    embed.add_field(name="üÉè Tr√≤ ch∆°i (Giao di·ªán UI)", value="`!blackjack <s·ªë_ti·ªÅn>` (`!bj`)\n`!mines <s·ªë_ti·ªÅn> <s·ªë_bom>`", inline=False)
    embed.add_field(name="üéÆ Game 24/7 (D√πng N√∫t)", value="T√¨m k√™nh **T√†i X·ªâu** v√† d√πng N√∫t ƒë·ªÉ c∆∞·ª£c.", inline=False)
    embed.add_field(name="üõ†Ô∏è L·ªánh Admin", value="`!admin_give @user <s·ªë_ti·ªÅn>`\n`!admin_set @user <s·ªë_ti·ªÅn>`\n`!admin_createcode <code> <reward>`\n`!admin_deletecode <code>`\n`!start_taixiu`\n`!stop_taixiu`\n`!admin_view @user` - Xem th√¥ng tin user\n`!admin_resetdaily @user` - Reset daily\n`!admin_announce #channel <n·ªôi dung>`", inline=False)
    embed.set_footer(text="Ch√∫c b·∫°n may m·∫Øn!"); await ctx.send(embed=embed)

# --- L·ªÜNH C∆† B·∫¢N V√Ä X√É H·ªòI ---
@bot.command(name='kiemtra', aliases=['balance', 'bal', 'sodu'])
async def balance_check(ctx):
    user_data = get_user_data(ctx.author.id); await ctx.send(f'ü™ô {ctx.author.mention}, b·∫°n ƒëang c√≥ **{user_data.get("balance", 0):,}** token.' if user_data else 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y s·ªë d∆∞ c·ªßa b·∫°n.')
@bot.command(name='daily')
async def daily_reward(ctx):
    user_id = ctx.author.id; user_data = get_user_data(user_id)
    if not user_data: await ctx.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return
    if user_data.get('last_daily'):
        try: last_daily_time = datetime.fromisoformat(user_data['last_daily']); cooldown = timedelta(hours=DAILY_COOLDOWN_HOURS)
        except: last_daily_time = None
        if last_daily_time and datetime.now(timezone.utc) < last_daily_time + cooldown:
            time_left = (last_daily_time + cooldown) - datetime.now(timezone.utc); hours_left = int(time_left.total_seconds() // 3600); minutes_left = int((time_left.total_seconds() % 3600) // 60)
            await ctx.send(f'{ctx.author.mention}, b·∫°n c·∫ßn ch·ªù **{hours_left} gi·ªù {minutes_left} ph√∫t** n·ªØa.'); return
    new_balance = update_balance(user_id, DAILY_REWARD)
    if new_balance is None: await ctx.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try: supabase.table('profiles').update({'last_daily': datetime.now(timezone.utc).isoformat()}).eq('user_id', user_id).execute(); await ctx.send(f'üéâ {ctx.author.mention}, b·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **{DAILY_REWARD}** token! S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await ctx.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t th·ªùi gian: {e}')
@bot.command(name='code')
async def redeem_code(ctx, code_to_redeem: str):
    user_id = ctx.author.id; user_data = get_user_data(user_id)
    if not user_data: await ctx.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return
    code_to_redeem = code_to_redeem.upper()
    try: code_response = supabase.table('gift_codes').select('*').eq('code', code_to_redeem).execute()
    except Exception as e: await ctx.send(f'L·ªói khi ki·ªÉm tra code: {e}'); return
    if not code_response.data: await ctx.send(f'M√£ `{code_to_redeem}` kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.'); return
    if code_to_redeem in user_data.get('used_codes', []): await ctx.send(f'B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ `{code_to_redeem}` n√†y r·ªìi.'); return
    reward = code_response.data[0]['reward']; new_balance = update_balance(user_id, reward)
    if new_balance is None: await ctx.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try: new_code_list = user_data.get('used_codes', []) + [code_to_redeem]; supabase.table('profiles').update({'used_codes': new_code_list}).eq('user_id', user_id).execute(); await ctx.send(f'üéÅ {ctx.author.mention}, b·∫°n ƒë√£ nh·∫≠p th√†nh c√¥ng m√£ `{code_to_redeem}` v√† nh·∫≠n ƒë∆∞·ª£c **{reward}** token! S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await ctx.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t code ƒë√£ d√πng: {e}')
@bot.command(name='bangxephang', aliases=['top'])
async def leaderboard(ctx, top_n: int = 10):
    if top_n <= 0: top_n = 10
    try:
        response = supabase.table('profiles').select('user_id', 'balance').order('balance', desc=True).limit(top_n).execute()
        if not response.data: await ctx.send('Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng.'); return
        embed = discord.Embed(title=f"üèÜ B·∫£ng X·∫øp H·∫°ng {top_n} ƒê·∫°i Gia üèÜ", color=discord.Color.gold()); rank_count = 1
        for user_data in response.data:
            try: user = await bot.fetch_user(user_data['user_id']) # An to√†n h∆°n
            except discord.NotFound: user = None
            user_name = user.display_name if user else f"User ID {user_data['user_id']}"
            embed.add_field(name=f"#{rank_count}: {user_name}", value=f"**{user_data.get('balance', 0):,}** ü™ô", inline=False); rank_count += 1
        await ctx.send(embed=embed)
    except Exception as e: await ctx.send(f'L·ªói khi l·∫•y b·∫£ng x·∫øp h·∫°ng: {e}')
@bot.command(name='chuyenxu', aliases=['give', 'transfer'])
async def transfer_tokens(ctx, recipient: discord.Member, amount: int):
    sender_id = ctx.author.id; recipient_id = recipient.id
    if sender_id == recipient_id: await ctx.send('B·∫°n kh√¥ng th·ªÉ t·ª± chuy·ªÉn cho ch√≠nh m√¨nh!'); return
    if amount <= 0: await ctx.send('S·ªë ti·ªÅn chuy·ªÉn ph·∫£i l·ªõn h∆°n 0!'); return
    sender_data = get_user_data(sender_id)
    if not sender_data: await ctx.send("L·ªói l·∫•y d·ªØ li·ªáu ng∆∞·ªùi g·ª≠i."); return
    if sender_data.get('balance', 0) < amount: await ctx.send(f'B·∫°n kh√¥ng ƒë·ªß ti·ªÅn. B·∫°n ch·ªâ c√≥ **{sender_data.get("balance", 0):,}** ü™ô.'); return
    try: update_balance(sender_id, -amount); new_recipient_balance = update_balance(recipient_id, amount); await ctx.send(f'‚úÖ {ctx.author.mention} ƒë√£ chuy·ªÉn **{amount:,}** ü™ô cho {recipient.mention}!')
    except Exception as e: await ctx.send(f'ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh chuy·ªÉn: {e}')
@bot.command(name='profile', aliases=['stats', 'thongke'])
async def profile(ctx, member: typing.Optional[discord.Member]):
    target_user = member or ctx.author; user_data = get_user_data(target_user.id)
    if not user_data: await ctx.send(f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho {target_user.mention}."); return
    balance = user_data.get('balance', 0); total_bet = user_data.get('total_bet', 0); total_won = user_data.get('total_won', 0); games_played = user_data.get('games_played', 0)
    net_profit = total_won - total_bet
    embed = discord.Embed(title=f"üìä H·ªì s∆° c·ªßa {target_user.display_name}", color=target_user.color); embed.set_thumbnail(url=target_user.display_avatar.url)
    embed.add_field(name="üí∞ S·ªë d∆∞", value=f"**{balance:,}** ü™ô", inline=True); embed.add_field(name="üé≤ S·ªë game ƒë√£ ch∆°i", value=f"{games_played:,}", inline=True)
    embed.add_field(name="üìà T·ªïng c∆∞·ª£c", value=f"{total_bet:,} ü™ô", inline=False); embed.add_field(name="üèÜ T·ªïng th·∫Øng", value=f"{total_won:,} ü™ô", inline=False)
    embed.add_field(name="üíπ L√£i/L·ªó r√≤ng", value=f"**{net_profit:,}** ü™ô", inline=False)
    await ctx.send(embed=embed)

# --- L·ªÜNH ADMIN ---
@bot.command(name='admin_give')
@commands.has_role(ADMIN_ROLE)
async def admin_give(ctx, member: discord.Member, amount: int):
    if amount == 0: await ctx.send("S·ªë l∆∞·ª£ng ph·∫£i kh√°c 0."); return
    user_id = member.id; new_balance = update_balance(user_id, amount)
    if new_balance is None: await ctx.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    if amount > 0: await ctx.send(f"‚úÖ ƒê√£ c·ªông **{amount:,}** ü™ô cho {member.mention}. S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.")
    else: await ctx.send(f"‚úÖ ƒê√£ tr·ª´ **{abs(amount):,}** ü™ô t·ª´ {member.mention}. S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.")
@bot.command(name='admin_set')
@commands.has_role(ADMIN_ROLE)
async def admin_set(ctx, member: discord.Member, amount: int):
    if amount < 0: await ctx.send("Kh√¥ng th·ªÉ set s·ªë d∆∞ √¢m."); return
    try: supabase.rpc('set_balance', {'user_id_input': member.id, 'amount_input': amount}).execute(); await ctx.send(f"‚úÖ ƒê√£ set s·ªë d∆∞ c·ªßa {member.mention} th√†nh **{amount:,}** ü™ô.")
    except Exception as e: await ctx.send(f"ƒê√£ x·∫£y ra l·ªói khi set balance: {e}")
@bot.command(name='admin_createcode')
@commands.has_role(ADMIN_ROLE)
async def admin_createcode(ctx, code: str, reward: int):
    if reward <= 0: await ctx.send("Ph·∫ßn th∆∞·ªüng ph·∫£i l·ªõn h∆°n 0."); return
    code = code.upper()
    try: supabase.table('gift_codes').insert({'code': code, 'reward': reward}).execute(); await ctx.send(f"‚úÖ ƒê√£ t·∫°o giftcode `{code}` tr·ªã gi√° **{reward:,}** ü™ô.")
    except Exception as e: await ctx.send(f"L·ªói! Code `{code}` c√≥ th·ªÉ ƒë√£ t·ªìn t·∫°i. ({e})")
@bot.command(name='admin_deletecode')
@commands.has_role(ADMIN_ROLE)
async def admin_deletecode(ctx, code: str):
    code = code.upper()
    try: response = supabase.table('gift_codes').delete().eq('code', code).execute()
    except Exception as e: await ctx.send(f"ƒê√£ x·∫£y ra l·ªói khi x√≥a code: {e}"); return
    if response.data: await ctx.send(f"‚úÖ ƒê√£ x√≥a th√†nh c√¥ng giftcode `{code}`.")
    else: await ctx.send(f"L·ªói! Kh√¥ng t√¨m th·∫•y giftcode n√†o t√™n l√† `{code}`.")
@bot.command(name='admin_view')
@commands.has_role(ADMIN_ROLE)
async def admin_view(ctx, member: discord.Member):
    user_data = get_user_data(member.id)
    if not user_data: await ctx.send("Kh√¥ng t√¨m th·∫•y user."); return
    embed = discord.Embed(title=f"üëÄ Xem th√¥ng tin: {member.display_name}", color=member.color)
    for key, value in user_data.items():
        if key == 'used_codes' and isinstance(value, list): embed.add_field(name=key, value=f"`{'`, `'.join(value)}`" if value else "Ch∆∞a d√πng code n√†o", inline=False)
        elif key == 'last_daily' and value:
             try: dt_object = datetime.fromisoformat(value).astimezone(VIETNAM_TZ); embed.add_field(name=key, value=f"{dt_object.strftime('%Y-%m-%d %H:%M:%S %Z')}", inline=False)
             except: embed.add_field(name=key, value=f"`{value}` (L·ªói format)", inline=False)
        elif isinstance(value, (int, float)): embed.add_field(name=key, value=f"`{value:,}`", inline=False)
        else: embed.add_field(name=key, value=f"`{value}`", inline=False)
    await ctx.send(embed=embed)
@bot.command(name='admin_resetdaily')
@commands.has_role(ADMIN_ROLE)
async def admin_resetdaily(ctx, member: discord.Member):
    try: supabase.table('profiles').update({'last_daily': None}).eq('user_id', member.id).execute(); await ctx.send(f"‚úÖ ƒê√£ reset th·ªùi gian `!daily` cho {member.mention}.")
    except Exception as e: await ctx.send(f"L·ªói khi reset daily: {e}")
@bot.command(name='admin_announce')
@commands.has_role(ADMIN_ROLE)
async def admin_announce(ctx, channel: discord.TextChannel, *, message: str):
    try: embed = discord.Embed(title="üì¢ Th√¥ng B√°o T·ª´ Admin üì¢", description=message, color=discord.Color.orange()); embed.set_footer(text=f"G·ª≠i b·ªüi {ctx.author.display_name}"); await channel.send(embed=embed); await ctx.message.add_reaction("‚úÖ")
    except Exception as e: await ctx.send(f"L·ªói khi g·ª≠i th√¥ng b√°o: {e}")

# --- GAME 24/7: T√ÄI X·ªàU (UI) ---
class BetModal(ui.Modal, title="ƒê·∫∑t c∆∞·ª£c"):
    def __init__(self, bet_type: str):
        super().__init__(); self.bet_type = bet_type
        self.amount_input = ui.TextInput(label=f"Nh·∫≠p s·ªë ti·ªÅn c∆∞·ª£c cho [ {bet_type.upper()} ]", placeholder="V√≠ d·ª•: 1000", style=discord.TextStyle.short)
        self.add_item(self.amount_input)
    async def on_submit(self, interaction: discord.Interaction):
        user_id = interaction.user.id
        try: amount = int(self.amount_input.value)
        except ValueError: await interaction.response.send_message("S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l√† m·ªôt con s·ªë!", ephemeral=True); return
        if amount <= 0: await interaction.response.send_message("S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!", ephemeral=True); return
        user_data = get_user_data(user_id)
        if not user_data: await interaction.response.send_message("L·ªói l·∫•y d·ªØ li·ªáu user.", ephemeral=True); return
        if user_data.get('balance', 0) < amount: await interaction.response.send_message(f"B·∫°n kh√¥ng ƒë·ªß ti·ªÅn! B·∫°n ch·ªâ c√≥ {user_data.get('balance', 0):,} ü™ô.", ephemeral=True); return
        current_bets[user_id] = {'type': self.bet_type, 'amount': amount}
        await interaction.response.send_message(f"‚úÖ B·∫°n ƒë√£ c∆∞·ª£c **{amount:,}** ü™ô v√†o c·ª≠a **{self.bet_type.upper()}** th√†nh c√¥ng!", ephemeral=True)
class TaiXiuGameView(ui.View):
    def __init__(self): super().__init__(timeout=None)
    @ui.button(label="T√†i", style=discord.ButtonStyle.secondary, emoji="‚ö´", custom_id="bet_tai")
    async def bet_tai_button(self, interaction: discord.Interaction, button: ui.Button): await interaction.response.send_modal(BetModal(bet_type="t√†i"))
    @ui.button(label="X·ªâu", style=discord.ButtonStyle.secondary, emoji="üü£", custom_id="bet_xiu")
    async def bet_xiu_button(self, interaction: discord.Interaction, button: ui.Button): await interaction.response.send_modal(BetModal(bet_type="x·ªâu"))
    @ui.button(label="Ch·∫µn", style=discord.ButtonStyle.secondary, emoji="üü°", custom_id="bet_chan")
    async def bet_chan_button(self, interaction: discord.Interaction, button: ui.Button): await interaction.response.send_modal(BetModal(bet_type="ch·∫µn"))
    @ui.button(label="L·∫ª", style=discord.ButtonStyle.secondary, emoji="üîµ", custom_id="bet_le")
    async def bet_le_button(self, interaction: discord.Interaction, button: ui.Button): await interaction.response.send_modal(BetModal(bet_type="l·∫ª"))
def get_bet_totals():
    totals = {'t√†i': 0, 'x·ªâu': 0, 'ch·∫µn': 0, 'l·∫ª': 0}
    for user_id, bet in current_bets.items(): totals[bet['type']] += bet['amount']
    return totals
@tasks.loop(seconds=60.0)
async def tai_xiu_game_loop():
    global game_message, current_bets
    if not game_channel_id: return
    channel = bot.get_channel(game_channel_id)
    if not channel: print("L·ªói: Kh√¥ng t√¨m th·∫•y k√™nh game!"); return
    current_bets = {}; jackpot_pool = get_jackpot_pool('taixiu'); history = get_taixiu_history()
    embed = discord.Embed(title="üé≤ PHI√äN T√ÄI X·ªàU M·ªöI üé≤", description="M·ªùi b·∫°n ch·ªçn c·ª≠a. **C√≤n 45 gi√¢y...**", color=discord.Color.gold())
    embed.add_field(name="T·ªâ l·ªá c∆∞·ª£c", value="‚Ä¢ T√†i - X·ªâu: **x1.9**\n‚Ä¢ Ch·∫µn - L·∫ª: **x1.9**\n‚Ä¢ *B·ªô Ba ƒê·ªìng Nh·∫•t*: N·ªï 10% H≈© / Nh√† c√°i ƒÉn", inline=False)
    embed.add_field(name="üí∞ H≈® T√ÄI X·ªàU üí∞", value=f"**{jackpot_pool:,}** ü™ô", inline=True)
    embed.add_field(name="üìà Soi c·∫ßu (g·∫ßn nh·∫•t b√™n ph·∫£i)", value=f"`{' | '.join(history)}`" if history else "Ch∆∞a c√≥ d·ªØ li·ªáu", inline=True)
    embed.add_field(name="T·ªïng C∆∞·ª£c Hi·ªán T·∫°i", value="‚Ä¢ T√†i: 0 ü™ô\n‚Ä¢ X·ªâu: 0 ü™ô\n‚Ä¢ Ch·∫µn: 0 ü™ô\n‚Ä¢ L·∫ª: 0 ü™ô", inline=False)
    embed.set_footer(text="Nh·∫•n n√∫t b√™n d∆∞·ªõi ƒë·ªÉ ƒë·∫∑t c∆∞·ª£c!")
    if game_message:
        try: await game_message.delete()
        except discord.NotFound: pass
    game_message = await channel.send(embed=embed, view=TaiXiuGameView())
    for i in range(4):
        await asyncio.sleep(10)
        totals = get_bet_totals()
        embed.description = f"M·ªùi b·∫°n ch·ªçn c·ª≠a. **C√≤n {45 - (i+1)*10} gi√¢y...**"
        embed.set_field_at(3, name="T·ªïng C∆∞·ª£c Hi·ªán T·∫°i", value=f"‚Ä¢ T√†i: {totals['t√†i']:,} ü™ô\n‚Ä¢ X·ªâu: {totals['x·ªâu']:,} ü™ô\n‚Ä¢ Ch·∫µn: {totals['ch·∫µn']:,} ü™ô\n‚Ä¢ L·∫ª: {totals['l·∫ª']:,} ü™ô", inline=False)
        try: await game_message.edit(embed=embed)
        except discord.NotFound: return
    embed.title = "üé≤ ƒêANG L·∫ÆC... üé≤"; embed.description = "ƒê√£ kh√≥a c∆∞·ª£c. Ch·ªù k·∫øt qu·∫£ trong gi√¢y l√°t..."; embed.color = discord.Color.dark_gray()
    await game_message.edit(embed=embed, view=None); await asyncio.sleep(5)
    d1, d2, d3 = random.randint(1, 6), random.randint(1, 6), random.randint(1, 6); total = d1 + d2 + d3
    is_tai, is_xiu, is_chan, is_le, is_triple = (11 <= total <= 17), (4 <= total <= 10), (total % 2 == 0), (total % 2 != 0), (d1 == d2 == d3)
    if is_triple: result_text, result_emoji, history_entry = f"B·ªô Ba ƒê·ªìng Nh·∫•t ({total})!", "üí£", "B·ªô Ba"
    elif is_tai and is_chan: result_text, result_emoji, history_entry = f"T√ÄI - CH·∫¥N ({total})", "‚ö´üü°", "T√†i Ch·∫µn"
    elif is_tai and is_le: result_text, result_emoji, history_entry = f"T√ÄI - L·∫∫ ({total})", "‚ö´üîµ", "T√†i L·∫ª"
    elif is_xiu and is_chan: result_text, result_emoji, history_entry = f"X·ªàU - CH·∫¥N ({total})", "üü£üü°", "X·ªâu Ch·∫µn"
    else: result_text, result_emoji, history_entry = f"X·ªàU - L·∫∫ ({total})", "üü£üîµ", "X·ªâu L·∫ª"
    history.append(history_entry);
    if len(history) > 10: history.pop(0)
    jackpot_contrib = 0; payout_log = []; triple_jackpot_win = 0; amount_per_player = 0
    if is_triple and len(current_bets) > 0 and jackpot_pool > 0:
        triple_jackpot_win = int(jackpot_pool * 0.10)
        jackpot_contrib -= triple_jackpot_win # Tr·ª´ ti·ªÅn h≈© ƒë√£ n·ªï
        amount_per_player = triple_jackpot_win // len(current_bets) # Chia ƒë·ªÅu
        if amount_per_player > 0 : payout_log.append(f"üí• **N·ªî H≈® B·ªò BA!** {triple_jackpot_win:,} ü™ô ƒë∆∞·ª£c chia!")
        else: triple_jackpot_win = 0 # Kh√¥ng ƒë·ªß ti·ªÅn chia th√¨ h·ªßy n·ªï

    for user_id, bet in current_bets.items():
        bet_type, amount = bet['type'], bet['amount']
        contrib = int(amount * 0.01); jackpot_contrib += contrib; winnings = 0; is_win = False
        user_winnings_from_jackpot = amount_per_player if is_triple else 0
        if not is_triple:
            if (bet_type == 't√†i' and is_tai) or (bet_type == 'x·ªâu' and is_xiu) or (bet_type == 'ch·∫µn' and is_chan) or (bet_type == 'l·∫ª' and is_le): is_win = True
        if is_win:
            winnings = int(amount * 0.9); net_gain = winnings + user_winnings_from_jackpot
            update_balance(user_id, net_gain); update_profile_stats(user_id, amount, net_gain)
            payout_log.append(f"<@{user_id}> th·∫Øng **{winnings:,}** ü™ô (c·ª≠a {bet_type}){' + **' + f'{user_winnings_from_jackpot:,}' + '** ü™ô t·ª´ h≈©!' if user_winnings_from_jackpot > 0 else ''}")
        else:
            loss = amount - contrib; net_gain = -loss + user_winnings_from_jackpot
            update_balance(user_id, net_gain); update_profile_stats(user_id, amount, net_gain)
            if user_winnings_from_jackpot > 0: payout_log.append(f"<@{user_id}> nh·∫≠n **{user_winnings_from_jackpot:,}** ü™ô t·ª´ h≈©!")

    new_jackpot = max(0, jackpot_pool + jackpot_contrib)
    supabase.table('jackpot').update({'pool_amount': new_jackpot, 'history': history}).eq('game_name', 'taixiu').execute()
    embed_result = discord.Embed(title=f"{result_emoji} K·∫æT QU·∫¢: {result_text} {result_emoji}", color=discord.Color.green() if any(wg > 0 for wg in [winnings, user_winnings_from_jackpot]) else discord.Color.red())
    embed_result.add_field(name="K·∫øt qu·∫£ x√∫c x·∫Øc", value=f"**{d1} | {d2} | {d3}** (T·ªïng: **{total}**)", inline=False)
    embed_result.add_field(name="üí∞ H≈© hi·ªán t·∫°i üí∞", value=f"**{new_jackpot:,}** ü™ô ({'+' if jackpot_contrib >= 0 else ''}{jackpot_contrib:,})", inline=False)
    if not payout_log: payout_log.append("Kh√¥ng c√≥ ai th·∫Øng/nh·∫≠n h≈© v√°n n√†y.")
    embed_result.add_field(name="Ng∆∞·ªùi th·∫Øng/Nh·∫≠n H≈©", value="\n".join(payout_log[:15]), inline=False)
    embed_result.set_footer(text="Phi√™n m·ªõi s·∫Ω b·∫Øt ƒë·∫ßu sau 5 gi√¢y...")
    try: await game_message.edit(embed=embed_result, view=None); await asyncio.sleep(5)
    except discord.NotFound: print("Tin nh·∫Øn T√†i X·ªâu kh√¥ng t√¨m th·∫•y ƒë·ªÉ c·∫≠p nh·∫≠t k·∫øt qu·∫£.")
@tai_xiu_game_loop.before_loop
async def before_taixiu_loop(): await bot.wait_until_ready()
@bot.command(name='start_taixiu')
@commands.has_role(ADMIN_ROLE)
async def start_taixiu(ctx):
    global game_channel_id; game_channel_id = ctx.channel.id
    if not tai_xiu_game_loop.is_running(): tai_xiu_game_loop.start(); await ctx.send(f"‚úÖ ƒê√£ b·∫Øt ƒë·∫ßu Game T√†i X·ªâu 24/7 t·∫°i k√™nh <#{game_channel_id}>.")
    else: await ctx.send(f"Game ƒë√£ ch·∫°y t·∫°i k√™nh <#{game_channel_id}> r·ªìi.")
@bot.command(name='stop_taixiu')
@commands.has_role(ADMIN_ROLE)
async def stop_taixiu(ctx):
    global game_channel_id
    if tai_xiu_game_loop.is_running(): tai_xiu_game_loop.stop(); game_channel_id = None; await ctx.send("‚úÖ ƒê√£ d·ª´ng Game T√†i X·ªâu.")
    else: await ctx.send("Game ch∆∞a ch·∫°y.")


# --- GAME THEO L·ªÜNH (C√ì HI·ªÜU ·ª®NG V√Ä KH√ìA) ---
# ... (D√°n to√†n b·ªô code cho !slots, !hilo, !tungxu, !xucxac, !baucua, !duangua, !quay, !baccarat t·ª´ user_17/user_19, nh·ªõ th√™m update_profile_stats) ...


# --- X·ªî S·ªê (LOTTERY) ---
# ... (D√°n to√†n b·ªô code cho !lottery group v√† lottery_draw_task t·ª´ user_17/user_19) ...


# --- ƒêO√ÅN S·ªê (GUESS THE NUMBER) ---
# ... (D√°n to√†n b·ªô code cho Class GuessTheNumberGame v√† l·ªánh !guessthenumber, !guess t·ª´ user_17/user_19) ...


# --- GAME GIAO DI·ªÜN UI (BLACKJACK & MINES) ---
# ... (D√°n to√†n b·ªô code cho Blackjack v√† Mines t·ª´ user_17/user_19, bao g·ªìm Class View, Button v√† l·ªánh ch√≠nh) ...


# --- CH·∫†Y BOT ---
if TOKEN:
    keep_alive(); bot.run(TOKEN)
else:
    print("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_TOKEN")
