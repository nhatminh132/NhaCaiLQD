# -*- coding: utf-8 -*-
import discord
from discord.ext import commands, tasks
from discord import ui
import os
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone, date, time
from supabase import create_client, Client
import typing
import random
import asyncio
import math
import discord.utils
import pytz # Th√™m th∆∞ vi·ªán m√∫i gi·ªù

# Import t·ªáp keep_alive
from keep_alive import keep_alive

# --- T·∫£i Token v√† C√†i ƒë·∫∑t Bot ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_KEY = os.getenv('SUPABASE_KEY')

# --- C√†i ƒë·∫∑t Supabase ---
if not SUPABASE_URL or not SUPABASE_KEY: print("L·ªñI: Kh√¥ng t√¨m th·∫•y SUPABASE_URL ho·∫∑c SUPABASE_KEY"); exit()
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# C√†i ƒë·∫∑t Bot Discord
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
bot = commands.Bot(command_prefix='!', intents=intents, help_command=None)

# --- BI·∫æN TO√ÄN C·ª§C CHO GAME ---
game_message = None # Tin nh·∫Øn game T√†i X·ªâu
game_channel_id = None # K√™nh game T√†i X·ªâu
current_bets = {} # C∆∞·ª£c v√°n T√†i X·ªâu hi·ªán t·∫°i
bot.blackjack_games = {} # L∆∞u c√°c v√°n Blackjack
bot.mines_games = {} # L∆∞u c√°c v√°n D√≤ M√¨n
bot.users_in_animation = set() # D√πng ƒë·ªÉ kh√≥a l·ªánh khi game c√≥ hi·ªáu ·ª©ng
bot.guess_the_number_game = None # L∆∞u state game ƒêo√°n S·ªë

# --- ƒê·ªäNH NGHƒ®A H·∫∞NG S·ªê ---
STARTING_TOKENS = 100
DAILY_REWARD = 50
DAILY_COOLDOWN_HOURS = 24
ADMIN_ROLE = "Bot Admin"
VIETNAM_TZ = pytz.timezone('Asia/Ho_Chi_Minh') # M√∫i gi·ªù VN
LOTTERY_DRAW_TIME = time(18, 0, 0, tzinfo=VIETNAM_TZ) # 18:00 VN h√†ng ng√†y
LOTTERY_TICKET_PRICE = 100 # Gi√° v√© s·ªë

# Roulette
RED_NUMBERS = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36]
BLACK_NUMBERS = [2, 4, 6, 8, 10, 11, 13, 15, 17, 20, 22, 24, 26, 28, 29, 31, 33, 35]
# (C√°c h·∫±ng s·ªë game kh√°c ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a g·∫ßn l·ªánh c·ªßa ch√∫ng)
BAU_CUA_FACES = {'b·∫ßu': 'B·∫ßu üçê', 'bau': 'B·∫ßu üçê', 'üçê': 'B·∫ßu üçê', 'cua': 'Cua ü¶Ä', 'ü¶Ä': 'Cua ü¶Ä', 't√¥m': 'T√¥m ü¶ê', 'tom': 'T√¥m ü¶ê', 'ü¶ê': 'T√¥m ü¶ê', 'c√°': 'C√° üêü', 'ca': 'C√° üêü', 'üêü': 'C√° üêü', 'g√†': 'G√† üêì', 'ga': 'G√† üêì', 'üêì': 'G√† üêì', 'nai': 'Nai ü¶å', 'ü¶å': 'Nai ü¶å'}
BAU_CUA_LIST = ['B·∫ßu üçê', 'Cua ü¶Ä', 'T√¥m ü¶ê', 'C√° üêü', 'G√† üêì', 'Nai ü¶å']
NUM_HORSES = 6; RACE_LENGTH = 20
SLOT_SYMBOLS = [('üçí', 10, 10), ('üçã', 9, 15), ('üçä', 8, 20), ('üçì', 5, 30), ('üîî', 3, 50), ('üíé', 2, 100), ('7Ô∏è‚É£', 1, 200)]
SLOT_WHEEL, SLOT_WEIGHTS, SLOT_PAYOUTS = [], [], {}
for (symbol, weight, payout) in SLOT_SYMBOLS: SLOT_WHEEL.append(symbol); SLOT_WEIGHTS.append(weight); SLOT_PAYOUTS[symbol] = payout
CARD_SUITS = ['‚ô•Ô∏è', '‚ô¶Ô∏è', '‚ô£Ô∏è', '‚ô†Ô∏è']
# J=10, Q=10, K=10, A=11/1 (BJ), A=1 (Baccarat), A=14 (Hilo)
CARD_RANKS_VALUE = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 1}
CARD_RANKS_BJ = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10, 'A': 11}
CARD_RANKS_HILO = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}


# --- C√ÄI ƒê·∫∂T RATE LIMIT TO√ÄN C·ª§C ---
global_cooldown = commands.CooldownMapping.from_cooldown(30, 60.0, commands.BucketType.default)

# --- QU·∫¢N L√ù D·ªÆ LI·ªÜU (SUPABASE) ---
def get_user_data(user_id: int) -> typing.Dict:
    try:
        response = supabase.table('profiles').select('*').eq('user_id', user_id).single().execute()
        return response.data
    except Exception as e:
        if "JSON object requested" in str(e): # User ch∆∞a t·ªìn t·∫°i, t·∫°o m·ªõi
             try:
                 insert_response = supabase.table('profiles').insert({'user_id': user_id, 'balance': STARTING_TOKENS, 'last_daily': None, 'used_codes': [], 'total_bet': 0, 'total_won': 0, 'games_played': 0}).execute()
                 return insert_response.data[0]
             except Exception as e2: print(f"L·ªói khi t·∫°o user m·ªõi {user_id}: {e2}"); return None
        else: print(f"L·ªói khi get_user_data cho {user_id}: {e}"); return None

def update_balance(user_id: int, amount: int) -> typing.Optional[int]:
    try:
        response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
        return response.data
    except Exception as e:
        print(f"L·ªói khi update_balance cho {user_id}: {e}")
        user_data = get_user_data(user_id) # Th·ª≠ t·∫°o/l·∫•y l·∫°i user
        if user_data:
             try:
                 response = supabase.rpc('adjust_balance', {'user_id_input': user_id, 'amount_input': amount}).execute()
                 return response.data
             except Exception as e2: print(f"L·ªói l·∫ßn 2 khi update_balance: {e2}")
        return None

def update_profile_stats(user_id: int, bet_amount: int, net_gain: int):
    try:
        current_stats = supabase.table('profiles').select('total_bet', 'total_won', 'games_played').eq('user_id', user_id).single().execute().data
        if not current_stats: return
        new_total_bet = current_stats.get('total_bet', 0) + bet_amount
        new_total_won = current_stats.get('total_won', 0) + max(0, net_gain) # Ch·ªâ c·ªông ph·∫ßn l·ªùi
        new_games_played = current_stats.get('games_played', 0) + 1
        supabase.table('profiles').update({'total_bet': new_total_bet, 'total_won': new_total_won, 'games_played': new_games_played}).eq('user_id', user_id).execute()
    except Exception as e: print(f"L·ªói khi update_profile_stats cho {user_id}: {e}")

def get_jackpot_pool(game_name: str):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        data = supabase.table(table_name).select('pool_amount').eq('game_name', game_name).single().execute().data
        return data['pool_amount'] if data else 0
    except Exception as e: print(f"L·ªói khi l·∫•y jackpot {game_name}: {e}"); return 0

def update_jackpot_pool(game_name: str, amount: int):
    try:
        table_name = 'jackpot' if game_name == 'taixiu' else 'progressive_jackpot'
        current_pool = get_jackpot_pool(game_name)
        new_pool = max(0, current_pool + amount)
        supabase.table(table_name).update({'pool_amount': new_pool}).eq('game_name', game_name).execute()
        return new_pool
    except Exception as e: print(f"L·ªói khi c·∫≠p nh·∫≠t jackpot {game_name}: {e}"); return get_jackpot_pool(game_name)

def get_taixiu_history():
    try:
        data = supabase.table('jackpot').select('history').eq('game_name', 'taixiu').single().execute().data
        return data['history'][-10:] if data and data['history'] else []
    except Exception as e: print(f"Loi khi lay history taixiu: {e}"); return []

# --- H√ÄM KI·ªÇM TRA & S·ª∞ KI·ªÜN BOT ---
@bot.before_invoke
async def global_check_before_command(ctx):
    # L·∫•y command object m·ªôt c√°ch an to√†n
    command = ctx.command
    if command and command.name == 'help': return # B·ªè qua check cho l·ªánh help

    bucket = global_cooldown.get_bucket(ctx.message)
    retry_after = bucket.update_rate_limit()
    if retry_after: raise commands.CommandOnCooldown(bucket, retry_after, commands.BucketType.default)

@bot.event
async def on_ready():
    bot.add_view(TaiXiuGameView())
    lottery_draw_task.start()
    print(f'Bot {bot.user.name} ƒë√£ s·∫µn s√†ng!')
    print('------')

@bot.event
async def on_command_error(ctx, error):
    command_name = ctx.command.name if ctx.command else "Unknown"
    if isinstance(error, commands.CommandOnCooldown):
        seconds = error.retry_after; await ctx.send(f"‚è≥ Bot ƒëang x·ª≠ l√Ω qu√° nhi·ªÅu y√™u c·∫ßu! Vui l√≤ng th·ª≠ l·∫°i sau **{seconds:.1f} gi√¢y**.", delete_after=5)
    elif isinstance(error, commands.MissingRole):
        await ctx.send(f"R·∫•t ti·∫øc {ctx.author.mention}, b·∫°n kh√¥ng c√≥ quy·ªÅn d√πng l·ªánh n√†y. C·∫ßn role `{ADMIN_ROLE}`.")
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send(f'C√∫ ph√°p sai! G√µ `!help` ƒë·ªÉ xem h∆∞·ªõng d·∫´n l·ªánh `{command_name}`.')
    elif isinstance(error, commands.BadArgument):
        if command_name in ['admin_give', 'admin_set', 'chuyenxu', 'profile', 'admin_view', 'admin_resetdaily']: await ctx.send('Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng ƒë√≥ ho·∫∑c s·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá.')
        elif command_name == 'lottery_buy': await ctx.send('Vui l√≤ng nh·∫≠p 6 s·ªë h·ª£p l·ªá (1-45).')
        elif command_name == 'admin_announce': await ctx.send('Kh√¥ng t√¨m th·∫•y k√™nh ƒë√≥.')
        else: await ctx.send('S·ªë ti·ªÅn c∆∞·ª£c ho·∫∑c s·ªë ƒëo√°n/s·ªë ng·ª±a/s·ªë bom kh√¥ng h·ª£p l·ªá.')
    elif isinstance(error, commands.CheckFailure):
        await ctx.send(f"‚è≥ {ctx.author.mention}, b·∫°n ƒëang c√≥ m·ªôt tr√≤ ch∆°i kh√°c ƒëang ch·∫°y. Vui l√≤ng ch·ªù cho n√≥ k·∫øt th√∫c!", ephemeral=True, delete_after=5)
    else:
        print(f"L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ l·ªánh '{command_name}': {error}")
        await ctx.send('ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i sau.')

def is_user_in_game(ctx):
    user_id = ctx.author.id
    if user_id in bot.blackjack_games: return False
    if user_id in bot.mines_games: return False
    if bot.guess_the_number_game and user_id in bot.guess_the_number_game.participants: return False
    if user_id in bot.users_in_animation: return False
    return True

# --- L·ªÜNH !HELP ---
@bot.command(name='help')
async def custom_help(ctx):
    embed = discord.Embed(title="Tr·ª£ gi√∫p Bot Casino üé∞", color=discord.Color.gold())
    embed.add_field(name="ü™ô L·ªánh C∆° b·∫£n", value="`!help`\n`!kiemtra` (`!bal`, `!sodu`)\n`!daily`\n`!code <m√£>`\n`!chuyenxu @user <s·ªë_ti·ªÅn>`\n`!bangxephang` (`!top`)\n`!profile [@user]` - Xem h·ªì s∆°", inline=False)
    embed.add_field(name="üé≤ Tr√≤ ch∆°i (G√µ l·ªánh)", value="`!slots <s·ªë_ti·ªÅn>` - Ch∆°i m√°y x√®ng.\n`!hilo <s·ªë_ti·ªÅn> <cao/th·∫•p>` - ƒêo√°n l√° b√†i ti·∫øp theo.\n`!tungxu <s·ªë_ti·ªÅn> <s·∫•p/ng·ª≠a>` - C∆∞·ª£c 50/50.\n`!xucxac <s·ªë_ti·ªÅn> <s·ªë_ƒëo√°n>` - ƒêo√°n s·ªë (1-6), th·∫Øng 1 ƒÉn 5.\n`!baucua <s·ªë_ti·ªÅn> <linh_v·∫≠t>` - C∆∞·ª£c B·∫ßu Cua T√¥m C√°.\n`!duangua <s·ªë_ti·ªÅn> <s·ªë_ng·ª±a>` - C∆∞·ª£c ƒëua ng·ª±a (1-6), th·∫Øng 1 ƒÉn 4.\n`!quay <s·ªë_ti·ªÅn> <lo·∫°i_c∆∞·ª£c>` - Ch∆°i Roulette.\n`!baccarat <s·ªë_ti·ªÅn> <player/banker/tie>`\n`!lottery buy <s1>..<s6>` - Mua v√© s·ªë (1-45)\n`!lottery result` - Xem k·∫øt qu·∫£ XS\n`!guessthenumber start <s·ªë_ti·ªÅn>` - B·∫Øt ƒë·∫ßu ƒëo√°n s·ªë\n`!guess <s·ªë>` - ƒêo√°n s·ªë (1-100)", inline=False)
    embed.add_field(name="üÉè Tr√≤ ch∆°i (Giao di·ªán UI)", value="`!blackjack <s·ªë_ti·ªÅn>` (`!bj`)\n`!mines <s·ªë_ti·ªÅn> <s·ªë_bom>`", inline=False)
    embed.add_field(name="üéÆ Game 24/7 (D√πng N√∫t)", value="T√¨m k√™nh **T√†i X·ªâu** v√† d√πng N√∫t ƒë·ªÉ c∆∞·ª£c.", inline=False)
    embed.add_field(name="üõ†Ô∏è L·ªánh Admin", value="`!admin_give @user <s·ªë_ti·ªÅn>`\n`!admin_set @user <s·ªë_ti·ªÅn>`\n`!admin_createcode <code> <reward>`\n`!admin_deletecode <code>`\n`!start_taixiu`\n`!stop_taixiu`\n`!admin_view @user` - Xem th√¥ng tin user\n`!admin_resetdaily @user` - Reset daily\n`!admin_announce #channel <n·ªôi dung>`", inline=False)
    embed.set_footer(text="Ch√∫c b·∫°n may m·∫Øn!"); await ctx.send(embed=embed)

# --- L·ªÜNH C∆† B·∫¢N V√Ä X√É H·ªòI ---
@bot.command(name='kiemtra', aliases=['balance', 'bal', 'sodu'])
async def balance_check(ctx):
    user_data = get_user_data(ctx.author.id); await ctx.send(f'ü™ô {ctx.author.mention}, b·∫°n ƒëang c√≥ **{user_data["balance"]:,}** token.' if user_data else 'ƒê√£ x·∫£y ra l·ªói khi l·∫•y s·ªë d∆∞ c·ªßa b·∫°n.')
@bot.command(name='daily')
async def daily_reward(ctx):
    user_id = ctx.author.id; user_data = get_user_data(user_id)
    if not user_data: await ctx.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return # Check user_data
    if user_data.get('last_daily'):
        try: last_daily_time = datetime.fromisoformat(user_data['last_daily']); cooldown = timedelta(hours=DAILY_COOLDOWN_HOURS)
        except: last_daily_time = None # X·ª≠ l√Ω l·ªói format th·ªùi gian
        if last_daily_time and datetime.now(timezone.utc) < last_daily_time + cooldown:
            time_left = (last_daily_time + cooldown) - datetime.now(timezone.utc); hours_left = int(time_left.total_seconds() // 3600); minutes_left = int((time_left.total_seconds() % 3600) // 60)
            await ctx.send(f'{ctx.author.mention}, b·∫°n c·∫ßn ch·ªù **{hours_left} gi·ªù {minutes_left} ph√∫t** n·ªØa.'); return
    new_balance = update_balance(user_id, DAILY_REWARD)
    if new_balance is None: await ctx.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return # Check update_balance
    try: supabase.table('profiles').update({'last_daily': datetime.now(timezone.utc).isoformat()}).eq('user_id', user_id).execute(); await ctx.send(f'üéâ {ctx.author.mention}, b·∫°n ƒë√£ nh·∫≠n ƒë∆∞·ª£c **{DAILY_REWARD}** token! S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await ctx.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t th·ªùi gian: {e}')
@bot.command(name='code')
async def redeem_code(ctx, code_to_redeem: str):
    user_id = ctx.author.id; user_data = get_user_data(user_id)
    if not user_data: await ctx.send("L·ªói l·∫•y d·ªØ li·ªáu user."); return
    code_to_redeem = code_to_redeem.upper()
    try: code_response = supabase.table('gift_codes').select('*').eq('code', code_to_redeem).execute()
    except Exception as e: await ctx.send(f'L·ªói khi ki·ªÉm tra code: {e}'); return
    if not code_response.data: await ctx.send(f'M√£ `{code_to_redeem}` kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n.'); return
    if code_to_redeem in user_data.get('used_codes', []): await ctx.send(f'B·∫°n ƒë√£ s·ª≠ d·ª•ng m√£ `{code_to_redeem}` n√†y r·ªìi.'); return
    reward = code_response.data[0]['reward']; new_balance = update_balance(user_id, reward)
    if new_balance is None: await ctx.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    try: new_code_list = user_data.get('used_codes', []) + [code_to_redeem]; supabase.table('profiles').update({'used_codes': new_code_list}).eq('user_id', user_id).execute(); await ctx.send(f'üéÅ {ctx.author.mention}, b·∫°n ƒë√£ nh·∫≠p th√†nh c√¥ng m√£ `{code_to_redeem}` v√† nh·∫≠n ƒë∆∞·ª£c **{reward}** token! S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.')
    except Exception as e: await ctx.send(f'ƒê√£ x·∫£y ra l·ªói khi c·∫≠p nh·∫≠t code ƒë√£ d√πng: {e}')
@bot.command(name='bangxephang', aliases=['top'])
async def leaderboard(ctx, top_n: int = 10):
    if top_n <= 0: top_n = 10
    try:
        response = supabase.table('profiles').select('user_id', 'balance').order('balance', desc=True).limit(top_n).execute()
        if not response.data: await ctx.send('Ch∆∞a c√≥ ai trong b·∫£ng x·∫øp h·∫°ng.'); return
        embed = discord.Embed(title=f"üèÜ B·∫£ng X·∫øp H·∫°ng {top_n} ƒê·∫°i Gia üèÜ", color=discord.Color.gold()); rank_count = 1
        for user_data in response.data:
            user = await bot.fetch_user(user_data['user_id']) # D√πng fetch_user ƒë·ªÉ an to√†n h∆°n
            user_name = user.display_name if user else f"User ID {user_data['user_id']}"
            embed.add_field(name=f"#{rank_count}: {user_name}", value=f"**{user_data.get('balance', 0):,}** ü™ô", inline=False); rank_count += 1
        await ctx.send(embed=embed)
    except Exception as e: await ctx.send(f'L·ªói khi l·∫•y b·∫£ng x·∫øp h·∫°ng: {e}')
@bot.command(name='chuyenxu', aliases=['give', 'transfer'])
async def transfer_tokens(ctx, recipient: discord.Member, amount: int):
    sender_id = ctx.author.id; recipient_id = recipient.id
    if sender_id == recipient_id: await ctx.send('B·∫°n kh√¥ng th·ªÉ t·ª± chuy·ªÉn cho ch√≠nh m√¨nh!'); return
    if amount <= 0: await ctx.send('S·ªë ti·ªÅn chuy·ªÉn ph·∫£i l·ªõn h∆°n 0!'); return
    sender_data = get_user_data(sender_id)
    if not sender_data: await ctx.send("L·ªói l·∫•y d·ªØ li·ªáu ng∆∞·ªùi g·ª≠i."); return
    if sender_data.get('balance', 0) < amount: await ctx.send(f'B·∫°n kh√¥ng ƒë·ªß ti·ªÅn. B·∫°n ch·ªâ c√≥ **{sender_data.get("balance", 0):,}** ü™ô.'); return
    try: update_balance(sender_id, -amount); new_recipient_balance = update_balance(recipient_id, amount); await ctx.send(f'‚úÖ {ctx.author.mention} ƒë√£ chuy·ªÉn **{amount:,}** ü™ô cho {recipient.mention}!')
    except Exception as e: await ctx.send(f'ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh chuy·ªÉn: {e}')
@bot.command(name='profile', aliases=['stats', 'thongke'])
async def profile(ctx, member: typing.Optional[discord.Member]):
    target_user = member or ctx.author; user_data = get_user_data(target_user.id)
    if not user_data: await ctx.send(f"Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho {target_user.mention}."); return
    balance = user_data.get('balance', 0); total_bet = user_data.get('total_bet', 0); total_won = user_data.get('total_won', 0); games_played = user_data.get('games_played', 0)
    net_profit = total_won - total_bet
    embed = discord.Embed(title=f"üìä H·ªì s∆° c·ªßa {target_user.display_name}", color=target_user.color); embed.set_thumbnail(url=target_user.display_avatar.url)
    embed.add_field(name="üí∞ S·ªë d∆∞", value=f"**{balance:,}** ü™ô", inline=True); embed.add_field(name="üé≤ S·ªë game ƒë√£ ch∆°i", value=f"{games_played:,}", inline=True)
    embed.add_field(name="üìà T·ªïng c∆∞·ª£c", value=f"{total_bet:,} ü™ô", inline=False); embed.add_field(name="üèÜ T·ªïng th·∫Øng", value=f"{total_won:,} ü™ô", inline=False)
    embed.add_field(name="üíπ L√£i/L·ªó r√≤ng", value=f"**{net_profit:,}** ü™ô", inline=False)
    await ctx.send(embed=embed)

# --- L·ªÜNH ADMIN ---
@bot.command(name='admin_give')
@commands.has_role(ADMIN_ROLE)
async def admin_give(ctx, member: discord.Member, amount: int):
    if amount == 0: await ctx.send("S·ªë l∆∞·ª£ng ph·∫£i kh√°c 0."); return
    user_id = member.id; new_balance = update_balance(user_id, amount)
    if new_balance is None: await ctx.send("L·ªói c·∫≠p nh·∫≠t s·ªë d∆∞!"); return
    if amount > 0: await ctx.send(f"‚úÖ ƒê√£ c·ªông **{amount:,}** ü™ô cho {member.mention}. S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.")
    else: await ctx.send(f"‚úÖ ƒê√£ tr·ª´ **{abs(amount):,}** ü™ô t·ª´ {member.mention}. S·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô.")
@bot.command(name='admin_set')
@commands.has_role(ADMIN_ROLE)
async def admin_set(ctx, member: discord.Member, amount: int):
    if amount < 0: await ctx.send("Kh√¥ng th·ªÉ set s·ªë d∆∞ √¢m."); return
    try: supabase.rpc('set_balance', {'user_id_input': member.id, 'amount_input': amount}).execute(); await ctx.send(f"‚úÖ ƒê√£ set s·ªë d∆∞ c·ªßa {member.mention} th√†nh **{amount:,}** ü™ô.")
    except Exception as e: await ctx.send(f"ƒê√£ x·∫£y ra l·ªói khi set balance: {e}")
@bot.command(name='admin_createcode')
@commands.has_role(ADMIN_ROLE)
async def admin_createcode(ctx, code: str, reward: int):
    if reward <= 0: await ctx.send("Ph·∫ßn th∆∞·ªüng ph·∫£i l·ªõn h∆°n 0."); return
    code = code.upper()
    try: supabase.table('gift_codes').insert({'code': code, 'reward': reward}).execute(); await ctx.send(f"‚úÖ ƒê√£ t·∫°o giftcode `{code}` tr·ªã gi√° **{reward:,}** ü™ô.")
    except Exception as e: await ctx.send(f"L·ªói! Code `{code}` c√≥ th·ªÉ ƒë√£ t·ªìn t·∫°i. ({e})")
@bot.command(name='admin_deletecode')
@commands.has_role(ADMIN_ROLE)
async def admin_deletecode(ctx, code: str):
    code = code.upper()
    try: response = supabase.table('gift_codes').delete().eq('code', code).execute()
    except Exception as e: await ctx.send(f"ƒê√£ x·∫£y ra l·ªói khi x√≥a code: {e}"); return
    if response.data: await ctx.send(f"‚úÖ ƒê√£ x√≥a th√†nh c√¥ng giftcode `{code}`.")
    else: await ctx.send(f"L·ªói! Kh√¥ng t√¨m th·∫•y giftcode n√†o t√™n l√† `{code}`.")
@bot.command(name='admin_view')
@commands.has_role(ADMIN_ROLE)
async def admin_view(ctx, member: discord.Member):
    user_data = get_user_data(member.id)
    if not user_data: await ctx.send("Kh√¥ng t√¨m th·∫•y user."); return
    embed = discord.Embed(title=f"üëÄ Xem th√¥ng tin: {member.display_name}", color=member.color)
    for key, value in user_data.items():
        if key == 'used_codes' and isinstance(value, list): embed.add_field(name=key, value=f"`{'`, `'.join(value)}`" if value else "Ch∆∞a d√πng code n√†o", inline=False)
        elif key == 'last_daily' and value:
             try: dt_object = datetime.fromisoformat(value).astimezone(VIETNAM_TZ); embed.add_field(name=key, value=f"{dt_object.strftime('%Y-%m-%d %H:%M:%S %Z')}", inline=False)
             except: embed.add_field(name=key, value=f"`{value}` (L·ªói format)", inline=False)
        elif isinstance(value, (int, float)): embed.add_field(name=key, value=f"`{value:,}`", inline=False) # Format s·ªë
        else: embed.add_field(name=key, value=f"`{value}`", inline=False)
    await ctx.send(embed=embed)
@bot.command(name='admin_resetdaily')
@commands.has_role(ADMIN_ROLE)
async def admin_resetdaily(ctx, member: discord.Member):
    try: supabase.table('profiles').update({'last_daily': None}).eq('user_id', member.id).execute(); await ctx.send(f"‚úÖ ƒê√£ reset th·ªùi gian `!daily` cho {member.mention}.")
    except Exception as e: await ctx.send(f"L·ªói khi reset daily: {e}")
@bot.command(name='admin_announce')
@commands.has_role(ADMIN_ROLE)
async def admin_announce(ctx, channel: discord.TextChannel, *, message: str):
    try: embed = discord.Embed(title="üì¢ Th√¥ng B√°o T·ª´ Admin üì¢", description=message, color=discord.Color.orange()); embed.set_footer(text=f"G·ª≠i b·ªüi {ctx.author.display_name}"); await channel.send(embed=embed); await ctx.message.add_reaction("‚úÖ")
    except Exception as e: await ctx.send(f"L·ªói khi g·ª≠i th√¥ng b√°o: {e}")

# --- GAME 24/7: T√ÄI X·ªàU (UI) ---
# ... (D√°n to√†n b·ªô code T√†i X·ªâu UI t·ª´ user_17/user_19) ...
class BetModal(ui.Modal, title="ƒê·∫∑t c∆∞·ª£c"): # ... (code nh∆∞ c≈©)
    pass
class TaiXiuGameView(ui.View): # ... (code nh∆∞ c≈©)
    pass
def get_bet_totals(): # ... (code nh∆∞ c≈©)
    pass
@tasks.loop(seconds=60.0)
async def tai_xiu_game_loop(): # ... (code nh∆∞ c≈©, bao g·ªìm c·∫£ x·ª≠ l√Ω n·ªï h≈©)
    pass
@tai_xiu_game_loop.before_loop
async def before_taixiu_loop(): await bot.wait_until_ready()
@bot.command(name='start_taixiu')
@commands.has_role(ADMIN_ROLE)
async def start_taixiu(ctx): # ... (code nh∆∞ c≈©)
    pass
@bot.command(name='stop_taixiu')
@commands.has_role(ADMIN_ROLE)
async def stop_taixiu(ctx): # ... (code nh∆∞ c≈©)
    pass


# --- GAME THEO L·ªÜNH (C√ì HI·ªÜU ·ª®NG V√Ä KH√ìA) ---
@bot.command(name='slots', aliases=['slot'])
@commands.check(is_user_in_game)
async def slots(ctx, bet_amount: int):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance']
    if bet_amount <= 0: await ctx.send('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!'); return
    if bet_amount > balance: await ctx.send(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.'); return
    bot.users_in_animation.add(user_id)
    try:
        final_results = random.choices(SLOT_WHEEL, weights=SLOT_WEIGHTS, k=3)
        embed = discord.Embed(title="üé∞ M√°y X√®ng üé∞", description="| - | - | - |", color=discord.Color.blue())
        embed.set_footer(text=f"{ctx.author.display_name} ƒë√£ c∆∞·ª£c {bet_amount:,} ü™ô")
        slot_message = await ctx.send(embed=embed)
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | - | - |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | {final_results[1]} | - |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        await asyncio.sleep(1.66); embed.description = f"| {final_results[0]} | {final_results[1]} | {final_results[2]} |"
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: raise asyncio.CancelledError("Message deleted")
        winnings = 0; jackpot_win = 0; is_jackpot = (final_results[0] == final_results[1] == final_results[2] == '7Ô∏è‚É£')
        if is_jackpot:
            jackpot_pool = get_jackpot_pool('slots'); winnings = jackpot_pool; jackpot_win = winnings
            embed.description += f"\n\n**üí•üí•üí• JACKPOT TI·∫æN TRI·ªÇN!!! üí•üí•üí•**"
            update_jackpot_pool('slots', -jackpot_pool); update_jackpot_pool('slots', 1000) # Reset v·ªÅ 1000
        elif final_results[0] == final_results[1] == final_results[2]:
            payout = SLOT_PAYOUTS[final_results[0]]; winnings = bet_amount * payout
            embed.description += f"\n\n**JACKPOT!** B·∫°n tr√∫ng 3x {final_results[0]} (1 ƒÉn {payout})!"
        elif final_results[0] == final_results[1] or final_results[1] == final_results[2]:
            matching_symbol = final_results[1]; winnings = bet_amount * 1
            embed.description += f"\n\nB·∫°n tr√∫ng 2x {matching_symbol} (1 ƒÉn 1)!"
        jackpot_contrib = int(bet_amount * 0.01) if not is_jackpot else 0
        if jackpot_contrib > 0: update_jackpot_pool('slots', jackpot_contrib)
        net_gain = winnings if is_jackpot else (winnings - jackpot_contrib if winnings > 0 else -(bet_amount - jackpot_contrib))
        new_balance = update_balance(user_id, net_gain)
        update_profile_stats(user_id, bet_amount, net_gain)
        if winnings > 0: embed.description += f"\nüéâ B·∫°n th·∫Øng **{winnings:,}** ü™ô!\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description += f"\n\nüò¢ Ch√∫c may m·∫Øn l·∫ßn sau.\nB·∫°n m·∫•t **{bet_amount:,}** ü™ô.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        current_jackpot = get_jackpot_pool('slots'); embed.add_field(name="üí∞ Jackpot Slots Hi·ªán T·∫°i", value=f"**{current_jackpot:,}** ü™ô", inline=False)
        try: await slot_message.edit(embed=embed)
        except discord.NotFound: await ctx.send(embed=embed)
    except asyncio.CancelledError: pass # B·ªè qua n·∫øu tin nh·∫Øn b·ªã x√≥a
    except Exception as e: print(f"L·ªói !slots: {e}")
    finally: bot.users_in_animation.discard(user_id)

@bot.command(name='hilo', aliases=['caothap'])
@commands.check(is_user_in_game)
async def hilo(ctx, bet_amount: int, choice: str):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance']
    choice = choice.lower().strip()
    if choice not in ['cao', 'th·∫•p', 'high', 'low']: await ctx.send('C√∫ ph√°p sai! Ph·∫£i c∆∞·ª£c `cao` ho·∫∑c `th·∫•p`.'); return
    if bet_amount <= 0: await ctx.send('S·ªë ti·ªÅn c∆∞·ª£c ph·∫£i l·ªõn h∆°n 0!'); return
    if bet_amount > balance: await ctx.send(f'B·∫°n kh√¥ng ƒë·ªß token. B·∫°n ch·ªâ c√≥ {balance:,} ü™ô.'); return
    bot.users_in_animation.add(user_id)
    try:
        rank1 = random.choice(list(CARD_RANKS_HILO.keys())); suit1 = random.choice(CARD_SUITS); val1 = CARD_RANKS_HILO[rank1]; card1_str = f"**{rank1}{suit1}** (Gi√° tr·ªã: {val1})"
        embed = discord.Embed(title="‚¨ÜÔ∏è Cao hay Th·∫•p ‚¨áÔ∏è", color=discord.Color.blue())
        embed.add_field(name="L√° b√†i ƒë·∫ßu ti√™n", value=card1_str, inline=False); embed.add_field(name="B·∫°n c∆∞·ª£c", value=f"**{bet_amount:,}** ü™ô v√†o **{choice.upper()}**", inline=False)
        embed.add_field(name="L√° b√†i ti·∫øp theo", value="ƒêang r√∫t b√†i...", inline=False); msg = await ctx.send(embed=embed); await asyncio.sleep(3)
        rank2 = random.choice(list(CARD_RANKS_HILO.keys())); suit2 = random.choice(CARD_SUITS); val2 = CARD_RANKS_HILO[rank2]; card2_str = f"**{rank2}{suit2}** (Gi√° tr·ªã: {val2})"
        embed.set_field_at(2, name="L√° b√†i ti·∫øp theo", value=card2_str, inline=False)
        is_win = False
        if val2 > val1 and choice in ['cao', 'high']: is_win = True
        elif val2 < val1 and choice in ['th·∫•p', 'low']: is_win = True
        elif val1 == val2: embed.add_field(name="K·∫øt qu·∫£", value="B·∫±ng nhau! Nh√† c√°i th·∫Øng.", inline=False)
        if val1 != val2: embed.add_field(name="K·∫øt qu·∫£", value=f"{val2} **{'L·ªöN H∆†N' if val2 > val1 else 'NH·ªé H∆†N'}** {val1}", inline=False)
        payout = bet_amount if is_win else -bet_amount; new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)
        if is_win: embed.description = f"üéâ **B·∫°n ƒë√£ th·∫Øng!**\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description = f"üò¢ **B·∫°n ƒë√£ thua!**\nB·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except Exception as e: print(f"L·ªói !hilo: {e}")
    finally: bot.users_in_animation.discard(user_id)

@bot.command(name='tungxu', aliases=['coinflip'])
@commands.check(is_user_in_game)
async def coinflip(ctx, bet_amount: int, choice: str):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance'] # ... (ki·ªÉm tra input)
    bot.users_in_animation.add(user_id)
    try:
        embed = discord.Embed(title="ü™ô ƒêang tung ƒë·ªìng xu...", description="ƒê·ªìng xu ƒëang xoay tr√™n kh√¥ng...", color=discord.Color.blue())
        msg = await ctx.send(embed=embed); await asyncio.sleep(2.5)
        result = random.choice(['s·∫•p', 'ng·ª≠a']); is_win = (choice == result) or (choice == 'sap' and result == 's·∫•p') or (choice == 'ngua' and result == 'ng·ª≠a')
        payout = bet_amount if is_win else -bet_amount; new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)
        embed.title = f"Tung ƒë·ªìng xu ü™ô... K·∫øt qu·∫£ l√† **{result.upper()}**!"
        if is_win: embed.description = f"üéâ B·∫°n ƒëo√°n ƒë√∫ng! B·∫°n th·∫Øng **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description = f"üò¢ B·∫°n ƒëo√°n sai! B·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except Exception as e: print(f"L·ªói !tungxu: {e}")
    finally: bot.users_in_animation.discard(user_id)

@bot.command(name='xucxac', aliases=['dice'])
@commands.check(is_user_in_game)
async def dice_roll(ctx, bet_amount: int, guess: int):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance'] # ... (ki·ªÉm tra input)
    bot.users_in_animation.add(user_id)
    try:
        embed = discord.Embed(title="üé≤ ƒêang gieo x√∫c x·∫Øc...", description="X√∫c x·∫Øc ƒëang lƒÉn...", color=discord.Color.dark_purple())
        msg = await ctx.send(embed=embed); await asyncio.sleep(2.5)
        result = random.randint(1, 6); is_win = (guess == result); winnings = bet_amount * 5 if is_win else 0
        payout = winnings if is_win else -bet_amount; new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)
        embed.title = f"Gieo x√∫c x·∫Øc üé≤... K·∫øt qu·∫£ l√† **{result}**!"
        if is_win: embed.description = f"üéâ Ch√≠nh x√°c! B·∫°n th·∫Øng **{winnings:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description = f"üò¢ B·∫°n ƒëo√°n sai! B·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except Exception as e: print(f"L·ªói !xucxac: {e}")
    finally: bot.users_in_animation.discard(user_id)

@bot.command(name='baucua', aliases=['bc'])
@commands.check(is_user_in_game)
async def bau_cua(ctx, bet_amount: int, choice: str):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance'] # ... (ki·ªÉm tra input)
    user_choice_full = BAU_CUA_FACES.get(choice.lower().strip())
    if not user_choice_full: await ctx.send('C√∫ ph√°p sai! Ph·∫£i c∆∞·ª£c v√†o `b·∫ßu`, `cua`, `t√¥m`, `c√°`, `g√†`, ho·∫∑c `nai`.'); return
    bot.users_in_animation.add(user_id)
    try:
        final_results = random.choices(BAU_CUA_LIST, k=3)
        embed = discord.Embed(title="ü¶Ä ƒêang l·∫Øc B·∫ßu Cua...", description="| ‚ùî | ‚ùî | ‚ùî |", color=discord.Color.dark_orange())
        embed.set_footer(text=f"{ctx.author.display_name} c∆∞·ª£c {bet_amount:,} ü™ô v√†o {user_choice_full}")
        msg = await ctx.send(embed=embed); current_display = ['‚ùî'] * 3
        for i in range(5):
            if i < 2: current_display[0] = random.choice(BAU_CUA_LIST)
            else: current_display[0] = final_results[0]
            if i < 3: current_display[1] = random.choice(BAU_CUA_LIST)
            else: current_display[1] = final_results[1]
            if i < 4: current_display[2] = random.choice(BAU_CUA_LIST)
            else: current_display[2] = final_results[2]
            embed.description = f"| **{current_display[0]}** | **{current_display[1]}** | **{current_display[2]}** |"
            try: await msg.edit(embed=embed)
            except discord.NotFound: raise asyncio.CancelledError("Message deleted")
            await asyncio.sleep(0.7)
        hits = final_results.count(user_choice_full); is_win = (hits > 0); winnings = bet_amount * hits if is_win else 0
        payout = winnings if is_win else -bet_amount; new_balance = update_balance(user_id, payout)
        update_profile_stats(user_id, bet_amount, payout)
        embed.title = "ü¶Ä L·∫Øc B·∫ßu Cua üé≤"
        if is_win: embed.description += f"\n\nüéâ **B·∫°n ƒë√£ th·∫Øng!** Tr√∫ng {hits} l·∫ßn.\nB·∫°n nh·∫≠n ƒë∆∞·ª£c **{winnings:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.green()
        else: embed.description += f"\n\nüò¢ **B·∫°n ƒë√£ thua!** B·∫°n m·∫•t **{bet_amount:,}** token.\nS·ªë d∆∞ m·ªõi: **{new_balance:,}** ü™ô."; embed.color = discord.Color.red()
        await msg.edit(embed=embed)
    except asyncio.CancelledError: pass
    except Exception as e: print(f"L·ªói !baucua: {e}")
    finally: bot.users_in_animation.discard(user_id)

@bot.command(name='duangua', aliases=['race'])
@commands.check(is_user_in_game)
async def dua_ngua(ctx, bet_amount: int, horse_number: int):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance'] # ... (ki·ªÉm tra input)
    bot.users_in_animation.add(user_id)
    try:
        # ... (logic game duangua v·ªõi hi·ªáu ·ª©ng)
        payout = winnings if is_win else -bet_amount
        update_profile_stats(user_id, bet_amount, payout)
        # ... (hi·ªÉn th·ªã k·∫øt qu·∫£)
    finally: bot.users_in_animation.discard(user_id)

# --- GAME M·ªöI THEO L·ªÜNH ---
@bot.command(name='baccarat')
@commands.check(is_user_in_game)
async def baccarat(ctx, bet_amount: int, choice: str):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance'] # ... (ki·ªÉm tra input)
    choice = choice.lower().strip()
    if choice not in ['player', 'banker', 'tie']: await ctx.send('C√∫ ph√°p sai! Ph·∫£i c∆∞·ª£c `player`, `banker`, ho·∫∑c `tie`.'); return
    bot.users_in_animation.add(user_id)
    try:
        # ... (logic game baccarat v·ªõi hi·ªáu ·ª©ng)
        update_profile_stats(user_id, bet_amount, payout) # C·∫≠p nh·∫≠t stats
        # ... (hi·ªÉn th·ªã k·∫øt qu·∫£)
    finally: bot.users_in_animation.discard(user_id)

# --- X·ªî S·ªê (LOTTERY) ---
@bot.group(name='lottery', aliases=['xs', 'loto'], invoke_without_command=True)
async def lottery(ctx): await ctx.send("L·ªánh x·ªï s·ªë: `!lottery buy <s1>..<s6>` ho·∫∑c `!lottery result`.")
@lottery.command(name='buy')
@commands.check(is_user_in_game)
async def lottery_buy(ctx, n1: int, n2: int, n3: int, n4: int, n5: int, n6: int):
    user_id, balance = ctx.author.id, get_user_data(ctx.author.id)['balance'] # ... (ki·ªÉm tra input)
    numbers = sorted(list(set([n1, n2, n3, n4, n5, n6])))
    if len(numbers) != 6: await ctx.send("Ph·∫£i ch·ªçn ƒë√∫ng 6 s·ªë kh√°c nhau."); return
    if not all(1 <= n <= 45 for n in numbers): await ctx.send("C√°c s·ªë ph·∫£i n·∫±m trong kho·∫£ng t·ª´ 1 ƒë·∫øn 45."); return
    if balance < LOTTERY_TICKET_PRICE: await ctx.send(f"B·∫°n kh√¥ng ƒë·ªß ti·ªÅn mua v√©! C·∫ßn {LOTTERY_TICKET_PRICE} ü™ô."); return
    # Tr·ª´ ti·ªÅn, L∆∞u v√©, C·∫≠p nh·∫≠t stats
    new_balance = update_balance(user_id, -LOTTERY_TICKET_PRICE)
    update_profile_stats(user_id, LOTTERY_TICKET_PRICE, -LOTTERY_TICKET_PRICE)
    today = datetime.now(VIETNAM_TZ).date()
    try: supabase.table('lottery_tickets').insert({'user_id': user_id, 'numbers': numbers, 'draw_date': str(today)}).execute(); await ctx.send(f"‚úÖ B·∫°n ƒë√£ mua th√†nh c√¥ng v√© s·ªë cho ng√†y {today.strftime('%d/%m/%Y')} v·ªõi c√°c s·ªë: `{' '.join(map(str, numbers))}`. S·ªë d∆∞: {new_balance:,} ü™ô.")
    except Exception as e: await ctx.send(f"L·ªói khi l∆∞u v√© s·ªë: {e}"); update_balance(user_id, LOTTERY_TICKET_PRICE); update_profile_stats(user_id, 0, LOTTERY_TICKET_PRICE) # Ho√†n ti·ªÅn
@lottery.command(name='result')
async def lottery_result(ctx):
    # ... (code xem k·∫øt qu·∫£ nh∆∞ c≈©)
    pass
@tasks.loop(time=LOTTERY_DRAW_TIME)
async def lottery_draw_task():
    # ... (code quay s·ªë nh∆∞ c≈©)
    pass

# --- ƒêO√ÅN S·ªê (GUESS THE NUMBER) ---
# (Class GuessTheNumberGame v√† c√°c l·ªánh !guessthenumber, !guess gi·ªØ nguy√™n)
class GuessTheNumberGame: # ... (code nh∆∞ c≈©)
    pass
@bot.command(name='guessthenumber', aliases=['gtn', 'doanso'])
@commands.check(is_user_in_game)
async def guess_the_number_start(ctx, bet_amount: int): # ... (code nh∆∞ c≈©)
    pass
@bot.command(name='guess', aliases=['doan'])
async def guess_number(ctx, number: int): # ... (code nh∆∞ c≈©)
    pass

# --- GAME GIAO DI·ªÜN UI (BLACKJACK & MINES) ---
# (To√†n b·ªô code Blackjack v√† Mines gi·ªØ nguy√™n, bao g·ªìm c√°c Class View, Button v√† l·ªánh ch√≠nh)
# ... (D√°n code game Blackjack UI t·ª´ phi√™n b·∫£n tr∆∞·ªõc) ...
# ... (D√°n code game Mines UI t·ª´ phi√™n b·∫£n tr∆∞·ªõc) ...


# --- CH·∫†Y BOT ---
if TOKEN:
    keep_alive(); bot.run(TOKEN)
else:
    print("L·ªñI: Kh√¥ng t√¨m th·∫•y DISCORD_TOKEN")
